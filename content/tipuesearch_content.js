var tipuesearch = {"pages": [{'title': 'member', 'text': '個人倉儲:  40723203  林家宜 \n 個人倉儲:  40723206  王冠驊 \n 個人倉儲:  40723209  吳耕甫 \n 個人倉儲:  40723233 \xa0陳謙諭 \n 個人倉儲:  40723238 \xa0黃語晨 \n 個人倉儲:  40723239 \xa0黃學聖 \n 個人倉儲:  40723241 \xa0葉承叡 \n 個人倉儲:  40739214  蔡伃捷 \n', 'tags': '', 'url': 'member.html'}, {'title': 'week', 'text': '', 'tags': '', 'url': 'week.html'}, {'title': 'w10-12', 'text': '', 'tags': '', 'url': 'w10-12.html'}, {'title': 'Solidwork開發起源', 'text': 'SolidWorks公司成立於1993年12月，其總部設在 美國 麻州 康克爾郡 ，西元1995年發表其第一款產品 SolidWorks 95 ，1997年被 達梭系統 併購，SolidWorks公司現在是達梭系統的子公司。 \n \n', 'tags': '', 'url': 'Solidwork開發起源.html'}, {'title': 'NX開發起源', 'text': '1960年-McDonnell Douglas Automation公司成立。 \n 1976年-收購 Unigraphics CAD/CAE/CAM系統的開發商—United Computing公司，UG的雛形問世。 \n 1983年-UG 上市。 \n 1986年-Unigraphics吸取了業界領先的、為實踐所證實的實體建模核心——Parasolid的部份功能。 \n 1989年-Unigraphics宣布支持UNIX平台及開放系統的結構，並將一個新的與STEP標準兼容的Parasolid引入UG。 \n 1990年-Unigraphics作為McDonnell Douglas（波音飛機公司）的機械CAD/CAE/CAM的標準。 \n 1991年-Unigraphics開始了從CAD/CAE/CAM大型機版本到工作站版本的轉移。 \n 1993年-Unigraphics引入複合建模的概念，可以實體建模、曲線建模、框線建模、半參數化及參數化建模。 \n 1995年-Unigraphics"首次"發布了Windows NT版本。 \n 1996年-Unigraphics發布了能自動進行干涉檢查的功能模塊、最先進的CAM模塊以及具有A類曲線造型能力的工業造型模塊。 \n 1997年-Unigraphics新增了包括WAVE（幾何連結器）在內的一系列工業領先的新增功能。WAVE可以定義、控制、評估產品模板。 \n 2000年-Unigraphics發布了新版本的UG17，第一個可以裝載包含深層嵌入「基於工程知識」。 \n 2001年-Unigraphics發布了新版本UG18，新版本對對話框進行了調整，使得在最少的對話框中能完成更多的工作。 \n 2002年-Unigraphics發布了UG NX1.0.。新版本繼承了UG18的優點，改進和增加了許多功能。 \n 2003年-Unigraphics發布了新版本UG NX2.0 。新版本是最新的行業標準，用於支持完整的產品工程。 \n 2004年-Unigraphics發布了新版本的UG NX3.0，它為用戶的產品設計與加工過程提供了數字化造型和驗證手段。 \n 2005年-Unigraphics發布了新版本的UG NX4.0，使得開發與應用更加簡單和快捷。 \n 2007年04月-UGS公司發布了NX 5.0的下一代數字產品開發軟體，幫助用戶以更快的速度開發創新產品。 \n 2008年06月-Siemens PLM Software發布UG NX 6.0，建立在新的同步建模技術基礎之上。 \n 2009年10月-Siemens PLM Software 宣布推出其旗艦數字化產品開發解決方案NX軟體的最新版。UG NX 7.0引入了「HD3D」（三維精確描述）功能，新增了同步建模技術的增強功能。修復了很多6.0所存在的漏洞。 \n 2010年5月-Siemens PLM Software在上海發布UG NX 7.5，工具箱將作為一個應用模塊與NX 7一起同步發布。 \n 2011年09月-Siemens PLM Software發布了UG NX 8.0 \n 2012年10月-Siemens PLM Software發布了UG NX 8.5 \n 2013年10月-Siemens PLM Software發布了UG NX 9.0 \n 2014年8月-Siemens PLM Software發布了UG NX 10.0 \n 2016年8月-Siemens PLM Software發布了UG NX 11.0 \n 2017年10月-Siemens PLM Software發布了UG NX 12.0 \n', 'tags': '', 'url': 'NX開發起源.html'}, {'title': 'Inventor開發起源', 'text': 'Inventor是美国AutoDesk公司推出的一款三维可视化实体模拟软件Autodesk Inventor Professional（AIP），目前已推出最新版本AIP2019。同时还推出了iphone版本，在 app store 有售。Autodesk Inventor Professional包括Autodesk Inventor三维设计软件；基于AutoCAD平台开发的二维机械制图和详图软件AutoCAD Mechanical；还加入了用于缆线和束线设计、管道设计及PCB IDF文件输入的专业功能模块，并加入了由业界领先的ANSYS技术支持的FEA功能，可以直接在Autodesk Inventor软件中进行应力分析。在此基础上，集成的数据管理软件Autodesk Vault-用于安全地管理进展中的设计数据。 \n 由于Autodesk Inventor Professional集所有这些产品于一体，因此提供了一个无风险的二维到三维转换路径，您能以自己的进度转换到三维，保护的二维图形和知识投资，并且清楚地知道自己在使用目前市场上DWG兼容性最强的平台。Autodesk Inventor Professional软件是一套全面的设计工具，用于创建和验证完整的数字样机；帮助制造商减少物理样机投入，以更快的速度将更多的创新产品推向市场。 \n Autodesk Inventor 产品系列正在改变传统的 CAD 工作流程：因为简化了复杂 三维模型 的创建，工程师即可专注于设计的功能实现。通过快速创建数字样机，并利用数字样机来验证设计的功能，工程师即可在投产前更容易发现设计中的错误。Inventor 能够加速概念设计到产品制造的整个流程，并凭借着这一创新方法，连续 7 年销量居同类产品之首。\n Autodesk Inventor Professional能够帮助用户充分利用原有的 AutoCAD 技能和 DWG 设计数据，从而体验数字样机带来的种种优势。 \n Autodesk Inventor Professional集成了业界领先的二维和三维设计功能。无需使用 数据转换器 ，利用DWG TrueConvert 就能直接读写 DWG 文件，同时还能保持与 三维模型 的关联性。 \n 借助 Autodesk Inventor Professional，用户可以轻松访问原有的二维信息，重复利用宝贵的设计数据。此外，由于用户可以将 Inventor 的工程图保存为 DWG 文件，因此他们可以将从数字样机中获得的分析结果与那些使用 AutoCAD 软件的合作伙伴及供应商共享。从三维零件和装配设计中生成的视图，如示意图和工厂布置图等，也可以与 AutoCAD 数据相集成。用户可以通过插入新的三维设计视图来更新原有的二维工程图，以降低升级现有设备的成本。 \n （新增功能）模板同步 \n 在 Inventor 中打开 DWG 文件，然后根据 DWG 文件中的 AutoCAD 样式自动创建图层和尺寸标注以及文本样式，从而减少根据客户的绘图标准创建工程图的时间。 \n （增强功能）易用性 \n 使AutoCAD用户快速熟练掌握三维设计工作流程 ，减少相关培训。利用带有可识别图标、AutoCAD兼容快捷键、光标提示以及撤销命令的熟悉设计环境，简化从AutoCAD软件向Inventor的过渡。用户简档功能提供面向 AutoCAD和Inventor专家的即插即用的简档，使用户可以按照自己的工作习惯配置Inventor。此外，用户可以将配置导出为XML文件，然后将其配置传输到另一台电脑上。 \n DWG 保存 \n 可将三维设计的结果表达保存为 DWG 格式，简化依赖 DWG 技术的供应商与合作伙伴之间的沟通。这样的DWG文件能在AutoCAD中以完全相同的效果进行查看、测量和打印，同时完全保持与原模型的关联更新。 \n DWG 的直接打开 \n 无需安装或学习AutoCAD，AutoCAD 工程图也可以直接在 Inventor 中打开，使用熟悉的Inventor 命令进行查看、打印和测量 。使用“复制”和“粘贴”命令将现有的二维设计 数据集成 到三维设计工作流程中。 \n 从 Inventor 视图生成 AutoCAD 图块 \n 降低那些从二维设计升级到三维设计项目的使用成本。该功能可以从Inventor 视图生成 AutoCAD 图块，因而用户可以使用 Inventor 重新设计子装配，然后将新工程图直接集成到原有视图中。 \n Inventor 与 AutoCAD Mechanical 的合作 \n 支持关联的二维和三维合作，加速产品上市时间、减少错误。利用这种合作特性，AutoCAD Mechanical 可以打开 Inventor 零件或装配，并关联创建AutoCAD Mechanical 的相关零件或装配工程图。当Inventor 中的设计发生变更时，AutoCAD Mechanica l工程图会随之更新。 \n \n', 'tags': '', 'url': 'Inventor開發起源.html'}, {'title': 'Creo(Pro E)開發起源', 'text': '\n pro-e是Pro/Engineer的簡稱，更常用的簡稱是ProE或Pro/E，Pro/E是美國參數技術公司（Parametric Technology Corporation，簡稱PTC）的重要產品，在目前的三維造型軟件領域中佔有著重要地位。 \n pro-e作為當今世界機械CAD/CAE/CAM領域的新標準而得到業界的認可和推廣，是現今主流的模具和產品設計三維CAD/CAM軟件之一。 \n Pro/ENGINEER在2010年8月改名為「 Creo Elements/Pro 」 \n 2011年6月再改名為「 Creo Parametric 」 \n', 'tags': '', 'url': 'Creo(Pro E)開發起源.html'}, {'title': '各軟體之特點分析與安裝流程', 'text': 'solidwork \n NX \n 特點分析 : \n 1.\xa0 3D CAD 建模 \n NX 在一個建模軟體解決方案中結合了線框、曲面、實體、參數和直接建模，便於您為設計任務選擇最佳工具。 \n 2.\xa0 裝配設計 \n NX 提供了最強大的 CAD 裝配設計工具。 NX 支持自頂向下和從底向上的裝配建模技術，能夠幫助您管理裝配模型，保證您的團隊井然有序地開展工作。 \n 3.\xa0\xa0產品結構設計 \n 針對產品內部結構、機械部分的設計；一個好產品首先要實用，因此，產品設計首先是功能，其次才是形狀。產品實現其各項功能完全取決於一個優秀的結構設計。 \n \n \n4.\xa0 逆向工程\n NX 提供高度靈活的逆向工程方法，您可以讓曲線、樣條和曲面自動適應經過平面處理的數據，為後續設計工程工作創建精確的 CAD 幾何體。 NX 還包含將掃描數據與 CAD 幾何體進行對比的工具，以便將公差保持在一定範圍內。 所獲得的模型有助於加快下游設計、仿真和製造流程。 \n 參考網址: https://kknews.cc/news/4oap34g.html \n 安裝流程 : \n virtualbox虛擬主機載點:\xa0 https://www.virtualbox.org/wiki/Downloads \n NX12虛擬主機版載點:\xa0 http://mde.tw/cad2019/content/NX.html \n \n \n Inventor \n 特點分析: \n 1.正确的设计工具 \n Inventor 产品线提供了一组全面的设计工具，支持三维设计和各种文档、管路设计和验证设计。Inventor 不仅包含数据管理软件、 AutoCAD \xa0 Mechanical的二维工程图和局部详图，还在此基础上加入与真正的DWG 兼容的三维设计。Inventor 提供的专家系统能以最快捷的方式生成制造用工程图，从而加速了从草图到成品的过程。 \n \n 2.满足设计需要的专用工具 \n \n 专用工具能够创建和验证管路系统设计，包括管材、管件和线束设计，从而节省时间并降低创建原型的成本。Autodesk Inventor Professional提供的工具能够创建完整的，包括复杂的管路系统的设计，同时自动创建精确的物料清单和完整的制造档。 \n 在创建之前进行 设计验证 。使用Autodesk Inventor Professional，可以模仿一个完整设计中各个组成部分的运动状态，并且准确地预测瞬间载荷和加速度。此外，集成的有限元分析工具能够帮助工程师完成应力应变和模态分析，避免相关设计错误。 \n Inventor 根据不同的软件产品配置，可提供不同的功能，从而使其成为AutoCAD 用户在制造过程中的最佳选择。 \n \n 3.数字原型 \n \n 创建数字原型以确定设计细节，节省制造真实零部件的成本。 \n \n 4.三维虚拟模型 \n \n 在设计初期验证和模拟设计结果，能创建创新的、高质量的产品。同时降低制造成本和缩短进入市场的时间。 \n 在完成实际机器之前，就完成对零件和装配的构思和功能 设计验证 。 \n 在设计过程中或完成设计后，能够简洁地察看草图、零件和装配。同时在设计过程中，帮助设计者选择最佳的设计方案。 \n 使用装配位置表达，在不同机构运动位置评估设计结果。 \n \n 5.干涉与接触检测 \n \n 使用Inventor装配检测工具减少设计错误并提高设计的工艺性。 \n 使用自动化工具测试零件在装配中的干涉。 \n 拖动某一个零件使其与另一个零件接触以验证两者之间的关系。 \n 在一组接触部件中选择独立的组成以确定该组成是否进行预想的规则运动。 \n \n 6.自动限制 \n \n 自动极限功能将自动监测选定的设计参数并在参数超出指定的范围时显示颜色标识警告以减少设计错误。使用自动限制功能可以监测长度、距离、角度、直径、周长、面积和质量。 \n \n 在Inventor装配环境下可将装配模型存为STL格式的文件以应用于快速成型。\xa0 \n \n 7.物理属性 \n \n 利用真实属性创建的数字原型可以完善产品的设计。在Inventor中创建的零件和装配都带有物理属性信息包括重心、材料、密度、颜色和纹理。这些物理属性信息能够帮助设计者完整表达设计意图。 \n \n 8.运动仿真 \n \n 使用Inventor 的设计者，可以利用运动 仿真 预测产品在真实条件下的运动状况。运动仿真可以减少创建真实零部件进行台架试验的时间和成本，也可以避免昂贵的咨询费用。 \n \n 9.模拟 \n \n 模拟机械装置和 原动力 的运转，以保证设计的正确性，同时也降低了创建真实零部件的费用。计算在整个运转周期内的约束条件，并且精确地调整原动力和结构的参数，加载符合实际的驱动载荷。同时可以分析机械装置中每一个零部件的位置、速度、加速度和载荷。 \n \n 10.输出到FEA \n \n 将连续时间段中选定时间点的工况传送到Autodesk用精确的工况条件进行应力应变分析并得出结果；据此调整零部件的尺寸形状，将材料确实用到真正需要的地方，而成本降到最低。 \n \n 11.定义负荷 \n \n 用载荷编辑器，加载不同的驱动载荷和力矩以及基于时间的力函数，确认设计结果在不同的载荷条件下的性能。 \n \n 12.可视性 \n \n 三维动画型的结果表达，将根据基础实体和工况、约束进行运动仿真。因此能充分的观察到验证设计的运动和性能。 \n \n 13.点轨迹 \n \n 根据精确的部件位置确定某结构和固定结构间的 间距 。选择模型中任意一点使用“轨迹”选项能记录在动作全程中每一瞬间该点的位置。保存零件和装配设计模拟的输出结果中将包括点轨迹和装配位置。 \n \n 14.运动仿真 曲线 图 \n \n 使用所提供的相关 图表 可以快速地表现出动态特性在机器的运转周期中的变化。这些特性包括位置、力和时间加速度。使用同一图表的多个副本可以比较模拟周期内每一点的不同特性。 \n \n 15.Microsoft Excel输出 \n \n 将运动轨迹的XY 数据输出 到Microsoft Exce 表格中进一步分析模拟结果并且把分析结果合并到产品设计结果的演示和报告中。 \n \n 16.调用约束 \n \n 可以简捷创建运动仿真并描述机构的运动过程。运动约束会分析出模拟过程中的相关零件和正确的运动副。也能先添加连接约束库中的标准运动约束。 \n 然后添加弹簧和 阻尼器 。能定义每一个连接处的摩擦系数。 \n \n 17.应力分析 \n \n 使用Inventor可通过应力分析确认零件在载荷下的变形等状况，以确认设计的合理性。 \n \n 18. 评估零件性能 \n \n 使用评估功能检测零件在真实操作条件下的变形使用材料选择分析，为零件选择最合理的材料种类和位移状况，省略了传统的计算和试验，节省了零件进行决策支持。 \n \n 19.材料选择分析 \n \n 选用的材料越少，每个零件的成本设计时间。就越低。同时还能节省运费、材料加工费和 仓储费 。 \n \n 20.安全系数 \n \n 在分析的基础上作出设计决策，并且协同运动仿真创建最合适的零件。能直观的表达安全系数超值的并为这些区域制定备用方案。 \n \n 21.应力分析 \n \n 在Inventor 中，借助ANSYS DesignSpace 可直接进行应力和疲劳分析。内嵌机制可分析的类型包括： 变形分析 、安全系数分析、 应力分析 和 模态分析 。其中应力分析包括最大和最小 主应力 分析。 \n \n 22.协同运动仿真 \n \n 分析零件在其运动过程中不同时间点的工况，并且导入这个运动仿真下的结果参数，然后进行分析， 观察在这个工况下的结果。 \n \n 23.模型简化 \n \n 在有限元分析中，能根据需要抑制对于分析结果可以忽略的结构特征，缩短分析计算的时间。 \n \n 24.无摩擦约束 \n \n 无摩擦约束使得零件分析的约束更为真实。例如销子能够在孔内旋转， 零件可沿面进行移动。 \n \n 25.薄壁件分析 \n \n 能识别 钣金 等薄壁零件中的高应力区域，并且确保薄壁金属零件可以承受运动 载荷 。 \n \n 26.易于使用的综合分析 \n \n 可以检查零件设计和研究零件更改的影响，但不需要中断零件设计过程或者退出Inventor 。分析过程并不需要对模型数据进行单独的转换。所以综合分析功能比独立方案更易于使用。能直接访问一般是为分析师设置的功能，因而不再依赖专家进行分析的过程。 \n \n 27.在装配环境下分析零件 \n \n 能在装配环境下进行零件分析，而不必打开这个零件。这样的 分析模式 会使设计者更好的了解零件在机构与装配中的情况。 \n \n 28.深入的结果观察 \n \n 因为分析计算工况和结果是依附于模型的，就可以修改模型并回到分析环境，再次进行运动仿真，获得新的计算结果。 \n \n 29.将分析数据输出到ANSYS \n \n Inventor 的分析可以直接应用于其他 ANSYS \xa0 产品中， 并且为工程检测和进一步的研究提供基础。这个功能还可以准确地把数据传递到更高级的ANSYS 模拟产品中。 \n \n 30.变形动画 \n \n 对变形的研究会更深入地了解零件在外力作用下的反应。这个结果可以制作成动画，并且存储为 AVI格式 的文件。 \n \n 31.共享验证结果 \n \n 输出AVI或者图形格式文件，能顺利地将分析结果添加到报告中。 \n \n 32.管路设计 \n \n 使用Inventor的设计管理可以节约创建管路和软管的时间。 \n \n 33.管路 \n \n 可以选择一个起点、一个终点和任意数量的中间点定义管路，便捷地创建和修改管路。它与工程图的完全关联使得三维装配发生更改时，管路也会随之自动更新。管路的位置可以用三维草图工具，对受约束的管路精确控制。这种方法可以使管路与设计规则在创建和修改管路的过程中保持一致，例如最小和最大长度标准。 \n \n 34.自定义 管路 弯曲 \n \n 在实际的管路设计中，可能需要弯曲一个管路，而不是插入一个弯头。自定义管路弯曲功能具有灵活性和控制力，即使对非标准设计也有效，可以按照创建刚性管路的方法创建具有自定义弯曲半径和角度的管路。 \n \n 35.软管 \n \n 创建与三维数字原型关联的精确的制造文档，确保软管和配件的完全匹配。系统会从资源中心调出合适的软管，并且根据所选的软管类型检查最小折弯半径。软管的长度会自动更新，并在长度累加命令中使用。 \n \n 36. 法兰 管 \n \n 当管路是 法兰连接 组成时，确保使用正确的配件和垫片。Inventor 会自动使用 法兰 配件组装管路，并且将接头处替换为法兰配件和对应的垫片。 \n \n 37.刚性 管路 \n \n 可对形状、弯曲角度和半径的有效控制，快捷地创建刚性管路。刚性管路还可以根据任意数量的弯曲以及多种自定义的弯曲角度和半径创建。其中对于半径和角度参数会加强对刚性管路形状的控制。 \n \n 38.管件库 \n \n 能自动从丰富的管件库中选取正确的管件进行放置，这就提高了设计质量，能顺畅地组织零件而避免繁杂的搜索过程。这个配件库包括了常用的行业标准， 如： ANSI 、 DIN 、ISO和JIS配件、管道和软管。也可以在库中添加或者编辑管件的属性，包括现有零件编号、以及管理用于配件、管道和其他标准件的文件名。 \n \n 39.焊接管 \n \n 定义焊接管时，需要创建精确的管路长度。Invntor 能自动使用焊接方式件组装管路，并且会自动调整每一段管路的长度，留出正确的焊缝间距。 \n \n 40.创建 管路 \n \n 自动使用与制造标准相符的真实零件组装管路。这个工具将管路和软管转化成实体管路，在这条管路上自动放置所需的配件、管段、刚性管和软管。在此过程中，将创建Inventor 的标准零件，以便快捷完成质量计算和干涉检测。此外，当管路长度为最大长度时，将自动放置中间接头，用户也可以指定自己的截断长度。 \n \n 41.ISOGEN 管路 文件输出 \n \n 这是为在第三方应用软件中自动创建管路设计的轴测工程图。按行业规则表达管路设计结果。ISOENG管路文件是一个行业标准软件Alias ISOGEN 格式的文件。根据这种文件，ISOGEN软件将创建一个包含轴测工程图的DXF? 或者DWG 文件。 \n \n 42.装配文档 \n \n 能快捷地将准确详细的管路和软管位置信息包含在装配文档中。由于所有的管道几何图元都是Inventor 自带的，所以可以使用标准的工程图功能创建装配工程图。 \n \n 43. 管路 样式 \n \n 增强了管路质量和制造支持，确保自动创建的管路始终与符合设计标准。创建管路样式支持螺纹， 焊接和 法兰 接头的使用。根据设计规则为自动或者手动管道配置相应的配件。设计规则包括最小管段长度和最小半径，以及两个接头间的最大长度。 \n \n 44.管路 折弯表 \n \n 避免错误。创建XYZ 或者YBC 格式的无关联的ASCII管路折弯表，这个表为制造提供了可靠的资料。 \n \n 45.支管配件 \n \n 扩展管道模型包括螺纹支管配件和焊接支管配件。使用交互式控件从资源中心调用支管配件并将其安放到现有管路上，可定义位置和角度。使用这种方法添加的支管配件会自动在现有管子上生成正确的附加孔。 \n \n 46.复制 管路 \n \n 通过便捷的复制，重复使用以前设计中的完整管路， 提高工作效率。 \n \n 47.布线设计 \n \n 使用Inventor 进行布线设计能够节省时间和资源。布线设计中包括了带状电缆的设计。 \n \n 48.智能导线创建 \n \n 保持电路图与三维导线线束设计的一致性，以便简化导线设计，并且减少制造失误。在Inventor 中，导线清单和接头通过内嵌的电子和实体模型数据的交互检测来控制线束设计的。因此所有的导线和接头都会显示在电缆设计的 三维模型 中。 \n \n 49.导入导线清单 \n \n 在装配环境下导入导线清单的同时保留电路图设计，可以减少和降低设计错误。可以从Auto C AD Electrical 或者第三方方案设计应用软件中导入大量的导线清单，并且检测和添加遗失的接头、接插件的针和导线定义。 \n \n 50.线束路径定义 \n \n 优化了电缆和线束部件的设计，确保留出制造需要的空间以减少由于不完整的设计定义引起的制造错误。使用选择一点后单击的方法来定义三维虚拟套管，并且可以通过添加点或移动现有点重新定义线束的形状。然后创建关联以确保设计部件更改时自动更新线束。 \n \n 51.导线布线 \n \n 可使用自动和手动布线模式，在保留对关键导线完全控制的同时，可快速布置数千条导线。可以使用以下三种布线功能将导线插入线束段中： \n 手动布线，需要明确选择布线路径。 \n 交互式布线，需要选择布线路径的起点和终点，用计算法以供 最短路径 的选择。 \n 自动布线，基于所有可行路径查找最短路径。 \n \n 52.带状电缆 \n \n 带状电缆能用三维数字模型表达，这就减少了电子设备的设计错误。在完全控制带状电缆扭曲位置和折叠位置的前提下，将带状电缆添加到设计中。 \n \n 53.XML输出 \n \n XML 输出功能，用一个易于阅读且与语言无关的XML 文件完整描述了线束数据。并且可以将导线连接信息导入AutoCAD Electrical 中，使得 电路图 和导线图的生成更加流畅。 \n \n 54.复制导线线束 \n \n 线束设计的重用，可节省设计时间。将以前的设计作为原型，复制和重复使用现有线束部件。 \n \n 55.生成报告 \n \n 使用统一的 数据存储 格式，优化并且自动创建报告。然后定义报告模式，运行报告，例如导线清单、终端图表、剖面表，以及设计和制造线束的其他报告。 \n \n 56.虚拟零件 \n \n 精确的物料清单意味着准确的采购和成本预算。只需要选择线束部件（ 如夹子、端子、绝缘线束和标签），然后将它们作为与Inventor 的物料清单完全集成的无图零件插入电缆设计中即可。 \n \n 57.计算线束直径 \n \n 使用三维可视 检查工具 和干涉检测工具可以精确的确定导线线束是否适合于整个装配。当添加或删除导线时，软件会自动计算线束直径，甚至还会考虑到导线直径以及线束之间必要的绝缘气隙。 \n \n 58.接头 \n \n 创建某公司特有的接插件库，这有利于在设计中插入合适的接插件。Inventor 提供了一个强大的接插件库以简化接插件的选择和放置。同时资源中心提供了易于使用的编辑器和自定义接插件功能，以便于添加和修改接插件的属性，例如接插件的零件编号和默认文件名。 \n \n 59.多线电缆 \n \n 跟踪各个电缆导线、 导线 插头和布线路径，可以提高质量并且避免错误，并创建完整的物料清单，其中包括准确的电缆长度和数量，最大程度的减少浪费。为多线电缆创建智能演示，跟踪电缆中正在使用或者可以使用的导线，使用布线以及取消布线命令将电缆中所有导线捆在一起。 \n 使用现有导线清单导入功能自动导入电缆。 \n 创建可以精确显示电缆数据的物料清单，而不是各条导线的物料清单。 \n 创建电缆的可配置报告。 \n 将 DWG 相关技巧合成到三维设计的工作流程中。以便更快捷地将零部件模型和工程图数据结合在一起，并使得设计者与依赖于DWG 技术的供应商和合伙人之间的交流更加顺畅。这个机制是将Inventor中的工程图存储为DWG格式的文件，并且提供了真实的显示表达、绘图输出和设计数据测量机制，同时完全保留了工程图的关联更新。 \n \n 60.打开DWG \n \n 文件在不安装或打开AutoCAD 的前提下直接打开二维设计的DWG 。在Inventor 中直接打开AutoCAD 的工程图，并使用熟悉的Inventor环境实施查看、出图和测量。用复制和粘贴命令，将现有的关联的二维设计数据插入三维设计工作环境中。 \n \n 61.从Inventor 的视图到AutoCAD 的块 \n \n 使用三维设计更新在原有二维环境中设计的项目，可以减少更新的成本。这个机制是将Inventor 中的视图转换成AutoCAD 的块， 因此可以在Inventor 中重复设计部件， 然后直接将新的工程图视图整合到原有的工程图中。 \n \n 62.零件设计 \n \n 基于“ 功能设计”，Inventor 帮助用户定位设计的功能需求，以进一步创建 三维模型 ，并节省设计具有竞争力产品的时间。 \n \n 63.草图绘制 \n \n 在创建零部件模型之前，需要对不同的设计决策进行评估。在Inventor 的草图环境中，能在二维环境中表达多种设计思路。通过简明的约束工具，实现不同的设计方案的讨论，草图可有不同的颜色、线形和线宽来支持不同方案的表达。 \n \n 64.几何结构分析 \n \n 创建具有高质量曲面模型，并且检测设计数据的可制造性，以降低制造成本。用于检查设计几何属性的大量分析工具可以在零件设计环境和构造环境中使用。分析工具包括： \n 斑马纹分析，增强了间距控制和显示的准确性，完成对曲面相切和连续性的可视化确认。 \n 高斯 曲面分析，提供曲面曲率分析结果。 \n 剖面 分析，使用不同的颜色表达最大和最小壁厚的区域。 \n 拔模斜度分析，使用不同的颜色表达基于开模方向的拔模角度，其中开模方向是由一条轴、一个面或者一个平面决定的。 \n 检测装配中两个成员或者两个面之间的最小距离。 \n \n 65.钣金件API \n \n Inventor 的 应用程序接口 (API)提供了钣金展开特征以及冲压库，CNC 自动化制造需要这些数据。因此可能把设计数据直接传送到CNC上，加快从设计到制成品的过程。 \n \n 66.从Autodesk AliasStudio导入 \n \n 可使用Autodesk AliasStudio 的概念设计数据，以减少完成三维设计的时间。重用AliasStudio的曲线和曲面，这些信息来自这两个产品内嵌的DWG 导入和导出工具。在Inventor构造环境中实施曲面的导入， 然后用灌注(Sculpt)特征工具将这些曲面整合到三维零件模型中。 \n \n 67.灌注工具 \n \n 使用灌注工具可以快捷地创建曲面围成的形状细节， 这里的曲面可以是在Inventor 创建的，也可以是从其他软件中导入的。还可以使用灌注工具添加或切除实体来编辑现有的模型，这就实现了基于一组封闭曲面或者从其他软件中导入的曲面构建而成 三维模型 。 \n \n 68.inventor中的扩展名 \n \n ipt 零件图 \n iam 装配图 \n ipn 分解图 \n idw 工程图 \n 安裝流程: \n https://kknews.cc/zh-tw/digital/v6er664.html \n Creo(Pro E) \n', 'tags': '', 'url': '各軟體之特點分析與安裝流程.html'}, {'title': 'w13-15', 'text': '', 'tags': '', 'url': 'w13-15.html'}, {'title': 'w16-18', 'text': '', 'tags': '', 'url': 'w16-18.html'}, {'title': 'W17 協同任務', 'text': '', 'tags': '', 'url': 'W17 協同任務.html'}, {'title': 'Building a clean model tutorial', 'text': "構建乾淨的模型教程 \n 40723203\xa0 林家宜 \n Building the visible shapes \n 建立可見的形狀 \n \xa0We could now directly create primitive shapes in CoppeliaSim with [Menu bar --> Add --> Primitive shape --> ...]. When doing this, we have the option to create pure shapes, or regular shapes. \n 可使用 [ 菜單欄 -> 添加 -> 基本形狀 -> ...] 在 CoppeliaSim 中直接創建基本形狀。 \n \xa0CoppeliaSim supports currently following CAD data formats: OBJ, STL, DXF, 3DS (Windows only), and Collada. URDF is also supported \n CoppeliaSim \n 當前支持以下 CAD 數據格式： OBJ ， STL ， DXF ， 3DS （僅 Windows ）和 Collada 。還支持 URDF \n *Automatic mesh division: \n *自動網格劃分： \n The function can be accessed with [Menu bar --> Edit --> Grouping/Merging --> Divide selected shapes]. Sometimes, a mesh will be divided more than expected. In that case, simply merge elements that logically belong together (i.e. that will have the same visual attributes and that are part of the same link) back into one single shape ([Menu bar --> Edit -> Grouping/Merging --> Merge selected shapes]). \n 可以通過 [ 菜單欄 -> 編輯 -> 分組 / 合併 -> 分割所選形狀 ] 訪問該功能。有時，網格劃分會超出預期。在這種情況下，只需將邏輯上屬於一起的元素（即，具有相同的視覺屬性並且屬於同一鏈接的一部分）合併回一個單一形狀（ [ 菜單欄 -> 編輯 -> 分組 / 合併 -> 合併選定的形狀 ] ）。 \n *Extract the convex hull: \n *提取凸包： \n allows to simplify the mesh by transforming it into a convex hull. The function can be accessed with [Menu bar --> Edit --> Morph selection into convex shapes]. \n 通過將其轉換為凸包來簡化網格。可以通過[菜單欄->編輯->將選擇變形為凸形]來訪問該功能。 \n *Decimate the mesh: \n 抽取網格： \n allows to reduce the number of triangles contained in the mesh. The function can be accessed with [Menu bar --> Edit --> Decimate selected shape...]. \n 減少網格中包含的三角形數量。可以通過[菜單欄->編輯->縮小所選形狀...]訪問該功能。 \n 40723241\xa0 葉承叡 \n *Remove the inside of the mesh:\xa0 \n 刪除網格的內部： \n \xa0allows to simplify the mesh by removing its inside. This function is based on\xa0 vision sensors \xa0and might give more or less satisfying results depending on the selected settings. The function can be accessed with [Menu bar --> Edit --> Extract inside of selected shape]. \n 允許通過刪除其內部來簡化網格。此功能基於 視覺傳感器 ，根據所選設置可能會或多或少地令人滿意。可以通過[菜單欄->編輯->提取選定形狀的內部]訪問該功能。 \n *Automatic mesh division: \n *自動網格劃分： \n this function, which was already described in previous section, will inspect the shape and generate a new shape for all elements that are not linked together via a common edge. This does not always work, but is always worth a try. The function can be accessed with [Menu bar --> Edit --> Grouping/merging --> Divide selected shapes]. \n 此功能已在上一節中進行了描述，它將檢查形狀並為未通過公共邊鏈接在一起的所有元素生成新形狀。這並不總是有效，但總是值得嘗試的。可以通過[菜單欄->編輯->分組/合併->分割所選形狀]訪問該功能。 \n *Manual mesh division: \n 手動網格劃分： \n via the the\xa0 triangle edit mode , you can manually select the triangles than logically belong together, then click\xa0Extract shape. This will generate a new shape in the scene. Delete the selected triangles after that operation. \n 通過 三角形編輯模式 ，您可以手動選擇邏輯上不屬於邏輯的三角形，然後單擊“\xa0提取形狀”。這將在場景中生成新形狀。完成該操作後，刪除選定的三角形。 \n we can group the shapes that are part of the same link with [Menu bar --> Edit --> Grouping/merging -> Group selected shapes]. We end up with shapes: the base of the robot (or base of the robot's hierarchy tree), and mobile links. \n 我們可以使用[菜單欄->編輯->分組/合併->分組所選形狀]對屬於同一鏈接的形狀進行分組。我們最終得到形狀：機器人的基礎（或機器人的層次結構樹的基礎）和移動鏈接。 \n When a shape is created or modified, CoppeliaSim will automatically set its reference frame position and orientation. A shape's reference frame will always be positioned at the shape's geometric center. The frame orientation will be selected so that the shape's bounding box remains as small as possible. This does not always look nice, but we can always reorient a shape's reference frame at any time. We now reorient the reference frames of all our created shapes with [Menu bar --> Edit --> Reorient bounding box --> with reference frame of world]. You have more options to reorient a reference frame in the\xa0 shape geometry dialog . \n 創建或修改形狀時，CoppeliaSim將自動設置其參考框架的位置和方向。形狀的參考框架將始終位於形狀的幾何中心。將選擇框架方向，以便形狀的邊界框保持盡可能小。這並不總是看起來不錯，但是我們隨時可以隨時調整形狀的參考框架的方向。現在，我們可以使用[菜單欄->編輯->重定向邊界框->使用世界參考框架]重新調整所有已創建形狀的參考框架。您可以在 形狀幾何對話框中 有更多選項來重新定向參考系。 \n 40739214 蔡伃捷 \n \n Building the joints \n 建立關節 \n Now we will take care of the joints/motors. Most of the time, we know the exact position and orientation of each of the joints. In that case, we simply add the joints with [Menu bar --> Add --> Joints --> ...], then we can change their position and orientation with the\xa0 position dialog \xa0and\xa0 orientation dialog . In other situations, we only have the Denavit-Hartenberg (i.e. D-H) parameters. In that case, we can build our joints via the tool model located in\xa0 Models/tools/Denavit-Hartenberg joint creator.ttm , in the model browser. \n 現在，我們將照顧關節/馬達。大多數時候，我們知道每個關節的確切位置和方向。在這種情況下，我們只需使用[菜單欄->添加->關節-> ...]添加關節，然後可以通過 位置對話框 和 方向對話框 更改它們的位置和方向。在其他情況下，我們只有Denavit-Hartenberg（即DH）參數。在這種情況下，我們可以通過 Models / tools / Denavit-Hartenberg 聯合 creator.ttm 中 的工具模型來構建關節，在模型瀏覽器中。 \n \xa0Othertimes, we have no information about the joint locations and orientations. Then, we need to extract them from the imported mesh. Let's suppose this is our case. Instead of working on the modified, more approximate mesh, we open a new scene, and import the original CAD data again. \n 有時，我們沒有關於關節位置和方向的信息。然後，我們需要從導入的網格中提取它們。讓我們假設這是我們的情況。無需處理修改過的，更近似的網格，而是打開一個新場景，然後再次導入原始CAD數據。 \n Most of the time, we can extract meshes or primitive shapes from the original mesh. The first step is to subdivide the original mesh. If that does not work, we do it via the\xa0 triangle edit mode . Let's suppose that we could divide the original mesh. We now have smaller objects that we can inspect. We are looking for revolute shapes, that could be used as reference to create joints at their locations, with the same orientation. \n \xa0大多數時候，我們可以從原始網格中提取網格或基本形狀。第一步是細分原始網格。如果這不起作用，我們通過 三角形編輯模式進行 。假設我們可以劃分原始網格。現在，我們可以檢查較小的對象。我們正在尋找旋轉形狀，可以用作在其位置以相同方向創建關節的參考。 \n First, remove all objects that are not needed. It is sometimes also useful to work across several opened scenes, for easier visualization/manipulation. In our case, we focus first on the base of the robot: it contains a cylinder that has the correct position for the first joint. In the triangle edit mode, we have: \n 首先，刪除所有不需要的對象。有時在多個打開的場景中工作也很有用，以便於可視化/操作。在我們的案例中，我們首先關注機器人的基座：它包含一個圓柱體，該圓柱體的第一個關節的位置正確。在三角形編輯模式下，我們有： \n \n [Robot base: normal and triangle edit mode visualization] \n [機器人基礎：法線和三角形編輯模式可視化] \n We change the camera view via the\xa0 page selector \xa0 toolbar button , in order to look at the object from the side. The\xa0 fit-to-view toolbar button \xa0can come in handy to correctly frame the object in edition. Then we switch to the\xa0 vertex edit mode \xa0and select all vertices that belong to the upper disc. Remember that by switching some\xa0 layers \xa0on/off, we can hide other objects in the scene. Then we switch back to the triangle edit mode: \n 我們通過 頁面選擇器 \xa0 工具欄按鈕 更改相機視圖，以便從側面查看對象。所述 擬合到視圖工具欄按鈕 可以派上用場正確幀在版的對象。然後，我們切換到 頂點編輯模式， 並選擇屬於上光盤的所有頂點。請記住，通過打開/關閉某些 層 ，我們可以隱藏場景中的其他對象。然後我們切換回三角形編輯模式： \n \n [Selected upper disc, vertex edit mode (1 & 2), triangle edit mode (3)] \n [選擇的上光盤，頂點編輯模式（1和2），三角形編輯模式（3）] \n Now we click\xa0 Extract cylinder \xa0( Extract shape \xa0would also work in that case), this just created a cylinder shape in the scene, based on the selected triangles. We leave the edit mode and discard the changes. Now we add a revolute joint with [Menu bar --> Add --> Joint --> Revolute], keep it selected, then control-select the extracted cylinder shape. In the\xa0 position dialog , on the\xa0 position \xa0tab, we click\xa0 Apply to selection : this basically copies the x/y/z position of the cylinder to the joint. \n 現在我們單擊“\xa0 提取圓柱體 ” （在這種情況下，“\xa0 提取形狀 ” 也將起作用），這只是根據選定的三角形在場景中創建了圓柱體形狀。我們離開編輯模式並放棄更改。現在，通過[菜單欄->添加->關節->旋轉]添加旋轉關節，使其保持選中狀態，然後控制選擇提取的圓柱形狀。在 位置 對話框 的“\xa0 位置 ” 選項卡上，單擊“\xa0 應用於選擇 ” ：這基本上將圓柱體的x / y / z位置複製到關節。 \n \xa0Both positions are now identical. In the\xa0 orientation dialog , on the\xa0 orientation \xa0tab, we also click\xa0 Apply to selection : the orientation of our selected objects is now also the same. Sometimes, we will need to additionally rotate the joint about 90/180 degrees around its own reference frame in order to obtain the correct orientation or rotation direction. We could do that on the\xa0 rotation \xa0tab of that dialog if needed (in that case, do not forget to click the\xa0 Own frame \xa0button). In a similar way we could also shift the joint along its axis, or even do more complex operations. This is what we have: \n 現在兩個位置都相同。在“\xa0 方向 ” 對話框 的“\xa0 方向 ” 選項卡上，我們還單擊“\xa0 應用於選擇 ” ：現在，所選對象的方向也相同。有時，我們將需要圍繞其自身的參考框架額外旋轉關節90/180度，以獲得正確的方向或旋轉方向。如果需要，我們可以在該對話框的“\xa0 旋轉 ” 選項卡上執行此操作（在這種情況下，請不要忘記單擊“\xa0 自有框架 ” 按鈕）。同樣，我們也可以沿關節的軸移動關節，甚至進行更複雜的操作。這就是我們所擁有的： \n \n [Joint in correct location, with the correct orientation] \n [在正確的位置，以正確的方向接合] \n Now we copy the joint back into our original scene, and save it (do not forget to save your work on a regular basis! The undo/redo function is useful, but doesn't protect you against other mishaps). We repeat above procedure for all the joints in our robot, then rename them. We also make all joints a little bit longer in the\xa0 joint properties , in order to see them all. By defaut, joints will be assigned to visibility layer 2, but can be changed in the\xa0 object common properties . We assign now all joints to visibility layer 10, then temporarily\xa0 enable visibility layer 10 for the scene \xa0to also visualize those joints (by default, only visibility layers 1-8 are activated for the scene). This is what we have (the model\xa0 ResizableFloor_5_25 \xa0was temporarily made invisible in the\xa0 model properties dialog ): \n 現在，我們將關節複製回到原始場景中，並保存它（不要忘記定期保存您的工作！撤消/重做功能很有用，但不能保護您免受其他不幸的影響）。我們對機器人中的所有關節重複上述過程，然後重命名它們。我們還將使所有關節的 關節屬性 稍長一些，以便查看所有 關節 。通過默認，關節將分配給可見性層2，但可以在 對象的公共屬性中 進行更改。現在，我們將所有關節分配給可見性層10，然後 為場景 臨時 啟用可見性層 10 ， 以使這些關節也可視化（默認情況下，僅激活場景的可見性層1-8）。這就是我們所擁有的（模型 ResizableFloor_5_25 在 模型屬性對話框中 暫時不可見）： \n \n [Joints in correct configuration] \n [接頭配置正確] \n At this point, we could start to build the model hierarchy and finish the model definition. But if we want opur robot to be\xa0 dynamically enabled , then there is an additional intermediate step: \n 至此，我們可以開始構建模型層次結構並完成模型定義。但是，如果我們希望 動態啟用 \xa0opur機器人，則還有一個額外的中間步驟： \n 40723238 黃語晨 \n Building the dynamic shapes \n 建立動態形狀 \n If we want our robot to be\xa0 dynamically enabled , i.e. react to collisions, fall, etc., then we need to create/configure the shapes appropriately: a shape can be: \n 如果我們希望 動態啟用 機器人，即對碰撞，跌落等做出反應，那麼我們需要適當地創建 / 配置形狀： \n \n dynamic or static: a dynamic (or non-static) shape will fall and be influences by external forces/torques. A static (or non-dynamic) shape on the other hand, will stay in place, or follow the movement of its parent in the scene hierarchy. \n respondable or non-respondable : a respondable shape will cause a collision reaction with other respondable shapes. They (and/or) their collider, will be influenced in their movement if they are dynamic. On the other hand, non-respondable shapes will not compute a collision response if they collide with other shapes. \n 動態或靜態： 動態（或非靜態）形狀會掉落並受到外力 / 扭矩的影響。另一方面，靜態（或非動態）形狀將保持不變，或跟隨其父級在場景層次中的移動。 \n   可響應或不可響應 ：可響應形狀會引起與其他可響應形狀的碰撞反應。如果它們是動態的，它們（和 / 或它們的對撞機）的運動將受到影響。另一方面，不負責任的形狀如果與其他形狀發生碰撞，則不會計算碰撞響應。 \n \n Above two points are illustrated\xa0 here. Respondable shapes should be as simple as possible, in order to allow for a fast and stable simulation. A physics engine will be able to simulate following 5 types of shapes with various degrees of speed and stability: \n 以上兩點都說明 這裡 。負責任的形狀應盡量簡單，以實現快速穩定的仿真。物理引擎將能夠以不同的速度和穩定性模擬以下5種類型的形狀： \n \n Pure shapes : a pure shape will be stable and handled very efficiently by the physics engine. The draw-back is that pure shapes are limited in geometry: mostly cuboids, cylinders and spheres. If possible, use those for items that are in contact with other items for a longer time (e.g. the feet of a humanoid robot, the base of a serial manipulator, the fingers of a gripper, etc.). Pure shapes can be created with [Menu bar --> Add --> Primitive shape]. \n 純形狀 ： 純形狀將穩定並由物理引擎非常有效地處理。缺點是純形狀的幾何形狀受到限制：主要是長方體，圓柱體和球體。如果可能的話，將它們用於與其他物品接觸時間較長的物品（例如，人形機器人的腳，串行操縱器的底座，抓手的手指等）。可以使用 [Menu bar --> Add --> Primitive shape] \n Pure compound shapes : a pure compound shape is a grouping of several pure shapes. It performs almost as well as pure shapes and shares similar properties. Pure compound shapes can be generated by grouping several pure shapes [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes]. \n 純複合形狀 ： 純複合形狀是幾個純形狀的組合。它的性能幾乎與純形狀一樣，並具有相似的特性。可以通過對幾個純形狀進行分組來生成純複合形狀 [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes] 。 \n Convex shapes : a convex shape will be a little bit less stable and take a little bit more computation time when handled by the physics engine. It allows for a more general geometry (only requirement: it need to be convex) than pure shapes. If possible, use convex shapes for items that are sporadically in contact with other items (e.g. the various links of a robot). Convex shapes can be generated with [Menu bar --> Add --> Convex hull of selection] or with [Menu bar --> Edit --> Morph selection into convex shapes]. \n 凹凸形狀 ：凸起的形狀會有點不太穩定，並採取一點點計算時間時通過物理引擎來處理。與純形狀相比，它允許使用更通用的幾何形狀（僅要求：它必須是凸形的）。如果可能，將凸形用於偶爾與其他物品接觸的物品（例如，機器人的各個鏈接）。可以使用 [Menu bar --> Add --> Convex hull of selection] 或 [Menu bar --> Edit --> Morph selection into convex shapes] 生成凸形。 \n \n \n Compound convex shapes, or convex decomposed shapes : a convex decomposed shape is a grouping of several convex shapes. It performs almost as well as convex shapes and shares similar properties. Convex decomposed shapes can be generated by grouping several convex shapes [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes], with [Menu bar --> Add --> Convex decomposition of selection...], or with [Menu bar --> Edit --> Morph selection into its convex decomposition...]. \n \n \xa0  複合凸形狀或凸分解形狀 ：凸分解形狀是幾個凸形狀的組合。它的性能幾乎與凸形相同，並具有相似的特性。可以通過將多個凸形分組 [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes] ，並使用 [Menu bar --> Add --> Convex decomposition of selection...] 來生成凸分解形狀。或使用 \n [Menu bar --> Edit --> Morph selection into its convex decomposition...]。 \n \n Random shapes : a random shape is a shape that is not convex nor pure. It generally has poor performance (calculation speed and stability). Avoid using random shapes as much as possible. \n 隨機形狀 ：較差勁。應盡量避免使用隨機形狀。 \n \n \xa0So the order of preference would be: pure shapes, pure compound shapes, convex shapes, compound convex shapes, and finally random shapes. Make sure to also read\xa0 this page . In case of the robot we want to build, we will make the base of the robot as a pure cylinder, and the other links as convex or convex decomposed shapes. \n 因此，優先順序為：純形狀，純複合形狀，凸形，複合凸形，最後是隨機形狀。確保還閱讀 此頁面 。對於要構建的機器人，我們將其基座設為純圓柱體，將其他鏈接設為凸形或凸形分解形狀。 \n We could use the dynamically enabled shapes also as the visible parts of the robot, but that would probably not look good enough. So instead, we will build for each visible shape we have created in\xa0 the first part of the tutorial \xa0a dynamically enabled counterpart, which we will keep hidden: the hidden part will represent the dynamic model and be exclusively used by the physics engine, while the visible part will be used for visualization, but also for\xa0 minimum distance calculations ,\xa0 proximity sensor detections , etc. \n 我們也可以將動態啟用的形狀用作機器人的可見部分，但是看起來可能不夠好。因此，相反，我們將為在 本教程第一部分中 創建的每個可見形狀構建一個動態啟用的副本，該副本將保持隱藏狀態：隱藏部分將代表動態模型，並由物理引擎專用，而可見部分將用於可視化，還用於 最小距離計算 ， 接近傳感器檢測 等。 \n We select object\xa0 robot , copy-and-paste it into a new scene (in order to keep the original model intact) and start the\xa0 triangle edit mode . If object\xa0 robot \xa0was a compound shape, we would first have had to ungroup it ([Menu bar --> Edit --> Grouping/Merging --> Ungroup selected shapes]) then merge the individual shapes ([Menu bar --> Edit --> Grouping/Merging --> Merge selected shapes]) before being able to start the triangle edit mode. Now we select the few triangles that represent the power cable, and erase them. Then we select all triangles in that shape, and click Extract cylinder. We can now leave the edit mode and we have our base object represented as a pure cylinder: \n 我們選擇對像 機器人 ，將其複制並粘貼到新場景中（以保持原始模型不變），然後啟動三角形編輯模式。如果對像 機器人 是複合形狀，我們首先必須將其取消組合（[Menu bar --> Edit --> Grouping/Merging --> Ungroup selected shapes]），然後合併各個形狀（[Menu bar --> Edit --> Grouping/Merging --> Merge selected shapes]）。現在，我們選擇代表電源線的幾個三角形，並將其刪除。然後，選擇該形狀中的所有三角形，然後單擊“提取圓柱體”。現在我們可以離開編輯模式，我們的基礎對象表示為純圓柱體： \n \n [純圓柱體生成過程，在三角形編輯模式下] \n 40723233 陳謙諭 \n We rename the new shape (with a double-click on its name in the\xa0 scene hierarchy ) as\xa0 robot_dyn \n 我們將新形狀（在 場景層次結構中 雙擊其名稱）重命名為 robot_dyn \n assign it to visibility layer 9, \n 將其分配給可見性層9， \n then copy it to the original scene. \n 然後將其複製到原始場景。 \n The rest of the links will be modelled as convex shapes, or compound convex shapes. We now select the first mobile link (i.e. object\xa0 robot_link1 ) \n 其餘鏈接將建模為凸形或複合凸形。現在，我們選擇第一個移動鏈接（即對象 robot_link1 ） \n We rename it to\xa0 robot_link_dyn1 \xa0 and assign it to visibility layer 9. \n 並使用[菜單欄->添加->選擇的凸包]從中生成凸形。我們將其重命名為 robot_link_dyn1 並將其分配給可見性層9。 \n When extracting the convex hull doesn't retain enough details of the original shape, \n 當提取凸包沒有保留足夠的原始形狀細節時， \n then you could still manually extract several convex hulls from its composing elements \n 您仍然可以從其組成元素中手動提取多個凸包， \n \xa0then group all the convex hulls with [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes]. \n 如果這似乎有問題或很耗時，則可以使用[菜單欄->添加->選擇的凸分解...]自動提取凸分解的形狀： \n If that appears to be problematic or time consuming, then you can automatically extract a convex decomposed shape with [Menu bar --> Add --> Convex decomposition of selection...]: \n 如果這似乎有問題或很耗時，則可以使用[菜單欄->添加->選擇的凸分解...]自動提取凸分解的形狀： \n \n [Original shape, and convex shape pendant] \n [原始形狀和凸形吊墜] \n \xa0 \n \n [Original shape, and convex decomposed shape pendant] \n [原始形狀和凸形分解形狀吊墜] \n \xa0 \n We now repeat the same procedure for all remaining robot links. \n 現在，我們對所有剩餘的機器人鏈接重複相同的過程。 \n Once that is done, we attach each visible shape to its corresponding invisible dynamic pendant. \n 完成後，我們將每個可見的形狀附加到其相應的不可見的動態吊墜上。 \n We do this by selecting first the visible shape, then via control-click selecting its dynamic pendant then [Menu bar --> Edit --> Make last selected object parent]. \n 為此，我們先選擇可見的形狀，然後按住Control鍵並單擊以選擇其動態吊墜，然後選擇[菜單欄->編輯->將最後選擇的對象設為父對象]。 \n The same result can be achieved by dragging the visible shape onto its dynamic pendant in the\xa0 scene hierarchy : \n 通過將可見形狀拖動到 場景層次 中的動態吊墜上，可以達到相同的結果 ： \n \n [Visible shapes attached to their dynamic pendants] \n [可見的形狀附加到動態吊墜上] \n \xa0 \n We still need to take care of a few things: \n 我們仍然需要注意一些事項： \n first, since we want the dynamic shapes only visible to the physics engine, but not to the other calculation modules, \n 首先，由於我們希望動態形狀僅對物理引擎可見，而對其他計算模塊不可見 ， \n we uncheck all\xa0 object special properties \xa0 for the dynamic shapes, in the \xa0 object common properties . \n 因此在 對象通用屬性中 取消選中 動態形狀的 所有 對象特殊屬性 。 \n Then, we still have to configure the dynamic shapes as\xa0 dynamic \xa0 and \xa0 respondable . \n 然後，我們仍然必須將動態形狀配置為 dynamic 和 responseable 。 \n We do this in the \xa0 shape dynamics properties . Select first the base dynamic shape (i.e. \xa0 robot_dyn ), \n 我們在 形狀動力學屬性中 執行此操作 。 首先選擇基本動態形狀（即 robot_dyn ）， \n then check the \xa0 Body is respondable \xa0 item. Enable the first 4 \xa0 Local respondable mask \xa0 flags, and disable the last 4 \xa0 Local respondable mask \xa0 flags: \n 然後檢查“\xa0 主體”是否為可響應 項。 啟用前四個“ \xa0 本地可響應掩碼” 標誌，並禁用後四個“ \xa0 本地可響應掩碼” 標誌： \n it is important for consecutive respondable links not to collide with each other. For the first mobile dynamic link in our robot (i.e. \xa0 robot_link_dyn1 ), \n 對於連續的可響應鏈接不要彼此衝突非常重要。對於機器人中的第一個移動動態鏈接（即 robot_link_dyn1 ）， \n we also enable the \xa0 Body is respondable \xa0 item, but this time we disable the first 4 \xa0 Local respondable mask \xa0 flags, and enable the last 4 \xa0 Local respondable mask \xa0 flags. \n 我們還啟用了“\xa0 身體可響應” 項，但是這次我們禁用了前四個“ \xa0 本地可響應”掩碼 標誌，並啟用最後4個 本地可響應掩碼 標誌。 \n We repeat the above procedure with all other dynamic links, while always alternating the \xa0 Local respondable mask \xa0 flags: \n 我們對所有其他動態鏈接重複上述過程，同時始終交替使用 Local Responsible Mask 標誌： \n once the model will be defined, consecutive dynamic shapes of the robot will not generate any collision response when interacting with each other. \n 一旦定義了模型，則連續的機器人動態形狀在彼此交互時不會產生任何碰撞響應。 \n Try to always end up with a construction where the dynamic base of the robot, and the dynamic last link of the robot have only the first 4 \xa0 Local respondable mask \xa0 flags enabled, \n 束嘗試始終以這樣一種構造結：機器人的動態基礎和機器人的動態最後一個鏈接僅啟用了前4個“\xa0 本地可響應掩碼” 標誌， \n so that we can attach the robot to a mobile platform, or attach a gripper to the last dynamic link of the robot without dynamic collision interferences. 。 \n 以便我們可以將機器人附加到移動平台，或附加一個抓取器連接到機器人的最後一個動態鏈接，沒有動態碰撞干擾。 \n Finally, we still need to tag our dynamic shapes as\xa0 Body is dynamic . \n 最後，我們仍然需要將動態形狀標記為 Body is dynamic 。 \n We do this also in the \xa0 shape dynamics properties . We can then enter the mass and inertia tensor properties manually, \n 我們也在 形狀動力學屬性中 執行此操作 。 然後，我們可以手動輸入質量和慣性張量屬性， \n or have those values automatically computed (recommended) by clicking \xa0 Compute mass & inertia properties for selected convex shapes . \n 或者通過單擊“\xa0 計算選定凸形的質量和慣性屬性”來 自動計算（推薦）那些值 。 \n Remember also \xa0 this \xa0 and \xa0 that \xa0 dynamic design considerations. \n 還請記住 這一點 以及 該 動態設計注意事項。 \n This dynamic base of the robot is a special case: most of the time we want the base of the robot (i.e. \xa0 robot_dyn ) to be non-dynamic (i.e. static), \n 機器人的動態基礎是一個特例：大多數情況下，我們需要機器人的基礎（即 robot_dyn ）為非動態（即靜態）， \n otherwise, if used alone, the robot might fall during movement. \n 否則，如果單獨使用，則機器人可能會在運動過程中掉落。 \n But as soon as we attach the base of the robot to a mobile platform, we want the base to become dynamic (i.e. non-static). \n 但是，一旦我們將機器人的底座連接到移動平台上，我們就希望底座變得動態（即非靜態）。 \n We do this by enabling the \xa0 Set to dynamic if gets parent \xa0 item, then disabling the \xa0 Body is dynamic item . \n 我們通過啟用“\xa0 如果獲取父 項時 設置為動態” 項，然後禁用“ \xa0 主體為動態項” \xa0 來 做到這一點 。 現在運行仿真： \n Now run the simulation: all dynamic shapes, except for the base of the robot, should fall. That attached visual shapes will follow their dynamic pendants. \n 除了機器人的基座之外，所有動態形狀都應下降。 附加的視覺形狀將跟隨其動態吊墜。 \n 40723239 黃學聖 \n Model definition \n Now we are ready to define our model. We start by building the model herarchy: we attach the last dynamic robot link ( robot_link_dyn6 ) to its corresponding joint ( robot_joint6 ) by selecting\xa0 robot_link_dyn6 , then control-selecting\xa0 robot_joint6 , then [Menu bar --> Edit --> Make last selected object parent]. We could also have done this step by simply dragging object\xa0 robot_link_dyn6 \xa0onto\xa0 robot_link6 \xa0in the\xa0 scene hierarchy . We go on by now attaching\xa0 robot_joint6 \xa0to\xa0 robot_link_dyn5 , and so on, until arrived at the base of the robot. We now have following scene hierarchy: \n 型號定義 \n 現在我們準備定義模型了。我們從建立模型層次結構開始：通過選擇 robot_link_dyn6 ，然後控制選擇 robot_joint6 ，然後選擇 [ 菜單欄 -> 編輯 -> 使最後一個選中的對象，將最後一個動態機器人鏈接（ robot_link_dyn6 ）附加到其相應的關節（ robot_joint6 ）。 ] 。我們也可以做這一步通過簡單的拖動對象 robot_link_dyn6 到 robot_link6 在 場景層次 。現在，我們將 robot_joint6 附加到 robot_link_dyn5 上 ，依此類推，直到到達機器人的底部。現在，我們具有以下場景層次結構： \n \xa0 \n So we rename\xa0 robot \xa0to\xa0 robot_visibleBase , and\xa0 robot_dyn \xa0to\xa0 robot . Now we select the base of the hierarchy tree (i.e. object\xa0 robot ) and in the\xa0 object common properties \xa0we enable\xa0 Object is model base . We also enable\xa0 Object/model can transfer or accept DNA . A model bounding box appeared, encompassing the whole robot. The bounding box however appears to be too large: this is because the bounding box also encompasses the invisible items, such as the joints. We now exclude the joints from the model bounding box by enabling the\xa0 Don't show as inside model selection \xa0item for all joints. We could do the same procedure for all invisible items in our model. This is also a useful option in order to also exclude large sensors or other items from the model bounding box. We now have following situation: \n 我們將 robot 重命名為 robot_visibleBase ，並將 robot_dyn 重命名為 robot 。現在，我們選擇層次結構樹的基礎（即對像 機械手 ），並在 對象公共屬性中 啟用 “\xa0 對象為模型基礎 ” 。我們還使 對象 / 模型可以轉移或接受 DNA 。出現了一個模型包圍盒，包圍了整個機器人。但是，邊界框似乎太大：這是因為邊界框還包含不可見的項，例如關節。現在，通過對所有關節啟用 “ 不顯示為內部模型 ” 選擇 項，將關節從模型邊界框中排除。我們可以對模型中的所有不可見項執行相同的過程。這也是一個有用的選項，可以將大型傳感器或其他項目也排除在模型邊界框之外。我們現在有以下情況： \n \xa0 \n We now protect our model from accidental modification. We select all visible objects in the robot, then enable\xa0 Select base of model instead : if we now click a visible link in the scene, the base of the robot will be selected instead. This allows us to manipulate the model as if it was a single object. We can still select visible objects in the robot via control-shift-clicking in the scene, or by selecting the object in the scene hierarchy. We now put the robot into a correct default position/orientation. First, we save current scene as a reference. Then we select the model and\xa0 modify its position/orientation \xa0appropriately. It is considered good practice to position the model (i.e. its base object) at X=0 and Y=0. \n 現在，我們保護模型免受意外修改。我們選擇機器人中所有可見的對象，然後啟用 “\xa0 選擇模型的基礎 ” ：如果現在單擊場景中的可見鏈接，則會改為選擇機器人的基礎。這使我們可以像對待單個對像一樣操作模型。我們仍然可以通過按住 Shift 鍵並單擊場景或在場景層次中選擇對象來選擇機器人中的可見對象。現在，我們將機器人置於正確的默認位置 / 方向。首先，我們將當前場景保存為參考。然後我們選擇模型並 修改其位置/ 方向 適當地。將模型（即其基礎對象）放置在 X = 0 和 Y = 0 處被認為是一種好習慣。 \n \xa0 \n We now run the simulation: the robot will collapse, since the joints are not controlled by default.\xa0 When we added the joints in the previous stage , we created joints in force/torque mode, but their motor or controller was disabled (by default). We can now adjust our joints to our requirements. In our case, we want a simple PID controller for each one of them. In the joint dynamic properties, we click\xa0 Motor enabled \xa0and adjust the\xa0 maximum torque . We then click\xa0 Control loop enabled \xa0and select\xa0 Position control (PID) . We now run the simulation again: the robot should hold its position. Try to switch the current physics engine to see if the behaviour is consistent across all supported physics engines. You can do this via the appropriate\xa0 toolbar button , or in the\xa0 general dynamics properties . \n 現在我們運行模擬：由於默認情況下關節不受控制，因此機器人將崩潰。 在上一階段添加關節時 ，我們以力 / 扭矩模式創建了關節，但其電動機或控制器已禁用（默認情況下）。現在，我們可以根據需要調整關節。在我們的案例中，我們希望為每個控制器都提供一個簡單的 PID 控制器。在關節動態屬性中，單擊 “\xa0 啟用電動機 ” 並調整 最大扭矩 。然後，我們點擊 “\xa0 啟用控制環 ” ， 然後選擇 “\xa0 位置控制（ PID ） ” 。現在，我們再次運行仿真：機器人應保持其位置。嘗試切換當前的物理引擎，以查看行為在所有受支持的物理引擎之間是否一致。您可以通過適當的 工具欄按鈕 ，或在 常規動力學屬性中執行此操作 。 \n \xa0 \n During simulation, we now verify the scene dynamic content via the\xa0 Dynamic content visualization & verification toolbar button . Now, only items that are taken into account by the physics engine will be display, and the display is\xa0 color-coded . It is\xa0 very important \xa0to always do this, and specially when your dynamic model doesn't behave as expected, in order to quickly debug the model. Similarly, always look at the scene hierarchy during simulation: dynamically enabled objects should display a ball-bounding icon on the right-hand side of their name. \n 在仿真過程中，我們現在通過 “\xa0 動態內容可視化和驗證” 工具欄按鈕來 驗證場景動態內容。現在，將僅顯示物理引擎考慮的項目，並且該顯示使用 顏色編碼 。這是 非常重要的 ，始終做到這一點，特別是當預期，為了快速調試模型動態模型不表現。同樣，在仿真過程中請始終查看場景層次：動態啟用的對象應在其名稱的右側顯示一個球形圖標。 \n Finally, we need to prepare the robot so that we can easily attach a gripper to it, or easily attach the robot to a mobile platform (for instance). Two dynamically enabled shapes can be rigidly attached to each other in two different ways: \n \uf0b7\xa0  by grouping them : select the shapes, then [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes]. \n \uf0b7\xa0  by attaching them via a force/torque sensor : a\xa0 force torque sensor \xa0can also act as a rigid link between two separate dynamically enabled shapes. \n In our case, only option 2 is of interest. We create a force/torque sensor with [Menu bar --> Add --> Force sensor], then move it to the tip of the robot, then attach it to object\xa0 robot_link_dyn6 . We change its size and visual appearance appropriately (a red force/torque sensor is often perceived as an optional attachment point, check the various robot models available). We also change its name to\xa0 robot_attachment : \n 最後，我們需要準備機器人，以便我們可以輕鬆地將抓取器連接到它，或輕鬆地將機器人連接到移動平台（例如）。可以通過兩種不同的方式將兩個動態啟用的形狀嚴格地彼此附加： \n \uf0b7\xa0  通過對它們進行分組 ：選擇形狀，然後單擊 [ 菜單欄 -> 編輯 -> 分組 / 合併 -> 對選定形狀進行分組 ] 。 \n \uf0b7\xa0  通過通過力 / 扭矩傳感器進行連接 ： 力扭矩傳感器 還可以充當兩個單獨的動態啟用形狀之間的剛性鏈接。 \n 在我們的情況下，只有選項 2 是有意義的。我們使用 [ 菜單欄 -> 添加 -> 力傳感器 ] 創建一個力 / 扭矩傳感器，然後將其移動到機器人的尖端，然後將其附加到對象 robot_link_dyn6 上 。我們會適當地更改其尺寸和外觀（紅色力 / 扭矩傳感器通常被視為可選的連接點，請檢查可用的各種機器人型號）。我們還將其名稱更改為 robot_attachment ： \n Now we drag a gripper model into the scene, keep it selected, then control-click the attachment force sensor, then click the\xa0 Assembling/disassembling toolbar button . The gripper goes into place: \n 現在，我們將抓取器模型拖到場景中，使其保持選中狀態，然後按住 Control 鍵並點按附件力傳感器，然後單擊 “\xa0 裝配/ 拆卸” 工具欄按鈕 。夾持器到位： \n The gripper knew how to attach itself because it was appropriately configured during its model definition. We now also need to properly configure the robot model, so that it will know how to attach itself to a mobile base for instance. We select the robot model, then click\xa0 Assembling \xa0in the\xa0 object common properties . Set an empty string for\xa0 'Parent' match values , then click\xa0 Set matrix . This will memorize the current base object's local transformation matrix, and use it to position/orient itself relative to the mobile robot's attachment point. To verify that we did things right, we drag the model\xa0 Models/robots/mobile/KUKA Omnirob.ttm \xa0into the scene. Then we select our robot model, then control-click one of the attachment points on the mobile platform, then click the\xa0 Assembling/disassembling toolbar button . Our robot should correctly place itself on top of the mobile robot: \n 抓具知道如何附加自身，因為它在模型定義期間進行了適當的配置。現在，我們還需要正確配置機器人模型，以便它將知道如何將自己附加到移動基座上。我們選擇機器人模型，然後在 對象公共屬性中 單擊 “\xa0 組裝 \xa0”\xa0 。為 “ 父項 ” 匹配值 設置一個空字符串，然後點擊 設置矩陣 。這將記住當前基礎對象的局部轉換矩陣，並使用它相對於移動機器人的附著點定位 / 定向。為了驗證我們做的正確，我們拖動模型 Models / robots / mobile / KUKA Omnirob.ttm 進入現場。然後，選擇機器人模型，然後在移動平台上按住 Control 鍵並單擊其中一個附接點，然後單擊 “\xa0 組裝/ 拆卸” 工具欄按鈕 。我們的機器人應該正確地將自己放置在移動機器人的頂部： \n Now we could add additional items to our robot, such as sensors for instance. At some point we might also want to attach\xa0 embedded scripts \xa0to our model, in order to control its behaviour or configure it for various purposes. In that case, make sure to understand\xa0 how object handles are accessed from embedded scripts . We can also control/access/interface our model from a\xa0 plugin , from a\xa0 remote API \xa0client, from a\xa0 ROS \xa0node, from a\xa0 BlueZero \xa0node, or from an\xa0 add-on . \n Now we make sure we have reverted the changes done during robot and gripper attachment, we collapse the hierarchy tree of our robot model, select the base of our model, then save it with [Menu bar --> File --> Save model as...]. If we saved it in the\xa0 model \xa0folder, then the model will be available in the\xa0 model brower . \n 現在，我們可以向機器人添加其他項目，例如傳感器。在某些時候，我們可能還希望將 嵌入式腳本 附加到我們的模型中，以便控制其行為或出於各種目的對其進行配置。在這種情況下，請確保了解 如何從嵌入式腳本訪問對象句柄 。我們還可以通過 插件 ， 遠程API 客戶端， ROS 節點， BlueZero 節點或 附加組件 來控制 / 訪問 / 接口模型。 \n 現在，確保已恢復在機械手和抓爪安裝過程中所做的更改，我們折疊了機械手模型的層次樹，選擇了模型的基礎，然後使用[菜單欄->文件->將模型另存為...]。如果我們將其保存在模型文件夾中，則該模型將在 模型瀏覽器中 可用。 \n", 'tags': '', 'url': 'Building a clean model tutorial.html'}, {'title': 'Webots User Guide Tutorial 2', 'text': '40723209 吳耕甫 \n First we create a new simulation based。 \n 首先，創建的模擬創建一個新的模擬。 \n We will now delete the\xa0RectangleArena\xa0node and add a simple floor。 \n 我們將刪除該 rectangleArena 節點，並添加一個簡單的地板。 \n To define a rigid body, you will have to create a\xa0Solid\xa0node. Inside this node you will set up different sub-nodes corresponding to the characteristics of the rigid body. The following\xa0figure\xa0depicts a rigid body and its sub-nodes. The graphical representation of the\xa0Solid\xa0node is defined by the\xa0Shapenodes populating its\xa0children\xa0list. The collision bounds are defined in its\xa0boundingObject\xa0field. The graphical representation and the collision shape are often but not necessarily identical. Finally, the\xa0physics\xa0field defines if the object belongs to the dynamical or to the static environment. All these sub-nodes are optional, but the\xa0physics\xa0field needs the boundingObject\xa0to be defined。 \n 要定義剛體，您將必須創建一個實體節點。在此節點內，您將根據剛體的特性設置不同的子節點。描繪了剛體及其子節點。實體節點的圖形表示由填充其列表的 Shape 節點定義children。碰撞範圍在其 boundingObject\xa0 字段中定義。圖形表示和碰撞形狀通常但不一定相同。最後，該physics字段定義對像是屬於動態環境還是屬於靜態環境。所有這些子節點都是可選的，但是physics需要 boundingObject\xa0 定義該字段。 \n In the scene tree view, select the last node and press the\xa0Add\xa0button. In the dialog, open the\xa0Bases nodes\xa0section and select the\xa0Solid\xa0node. In the scene tree view, expand the\xa0Solid\xa0node and select its\xa0children\xa0field. Add a\xa0Shape\xa0node to it by using the\xa0Add\xa0button. Select the\xa0appearance\xa0field of the\xa0Shape\xa0node and use the\xa0Add\xa0button to add a\xa0PBRAppearance\xa0node. \n 在場景樹視圖中，選擇最後一個節點，然後按 Add 按鈕。在對話框中，打開該 Bases nodes 部分，然後選擇實體節點。在場景樹視圖中，展開實體節點並選擇其 children 字段。使用按鈕向其添加一個 Shape 節點 Add 。選擇形狀節點的 appearance 字段，然後使用按鈕添加一個節點。 AddPBRAppearance 。 \n 1.Add a\xa0Sphere\xa0node as the\xa0geometry\xa0field of the newly created\xa0Shape node. \n 2.Expand the\xa0PBRAppearance\xa0node and change its\xa0metalness\xa0field to 0 and its\xa0roughness\xa0field to 1. \n 3.Add another\xa0Sphere\xa0node to the\xa0boundingObject\xa0field of the\xa0Solid. \n 4.Finally add a\xa0Physics\xa0node to the\xa0physics\xa0field of the\xa0Solid. \n 5.By modifying the\xa0translation\xa0field of the\xa0Solid\xa0node, place the ball in front of the robot \n 6.Save the simulation. \n 1.將球體節點添加為 geometry 新創建的形狀節點的字段。 \n 2.展開 PBRAppearance 節點並將其 metalness 字段更改為 0 ，並將其 roughness 字段更改為 1 。 \n 3.將另一個 Sphere 節點添加到 Solid 的 boundingObject 字段。 \n 4.最後，將一個 Physics 節點添加到 Solid 的 physics 字段中。 \n 5.通過修改實體節點的 translation 字段，將球放在機器人的前面 \n 6.保存模擬。 \n 40723206 王冠驊 \n DEF-USE Mechanism \n 定義使用機制 \n The\xa0 DEF-USE mechanism \xa0allows to define a node in one place and to reuse that definition elsewhere in the scene tree. This is useful to avoid the duplication of identical nodes in world files. Moreover, it also allows users to modify several objects at the same time. \n 該 DEF-USE機制 允許在一個地方定義一個節點，並在場景樹在其他地方重複使用的定義。 這對於避免在世界文件中復制相同節點很有用。 此外，它還允許用戶同時修改多個對象。 \n The two\xa0 Sphere \xa0 definitions that we have used earlier to define the ball, are redundant. We will now merge these two \xa0 Spheres \xa0 into only once using the DEF-USE mechanism. \n 我們之前用來定義球的兩個 Sphere 定義是多餘的。 現在，我們將 使用DEF-USE機制 將這兩個 Sphere 合併 為一次。 \n Now, changing the \xa0 radius \xa0 field of the first \xa0 Sphere \xa0 node also modifies its \xa0 boundingObject .For convenience, the \xa0 boundingObject \xa0 field accepts also the \xa0 Shape \xa0 node (rather than the \xa0 Sphere \xa0 node directly). It would be also possible to use the same DEF-USE mechanism at the \xa0 Shape \xa0 level as shown in \xa0 this figure . For now the greatest benefit is being able to also use this \xa0 Shape \xa0 directly for graphical purposes. Later this mechanism will turn out to be very useful for some sensors. \n 現在，更改 radius 第一個 Sphere 節點的字段也會修改其 boundingObject 。 為方便起見，該 boundingObject 字段還接受 Shape 節點（而不是 直接 接受 Sphere 節點）。 也可以在 Shape 級別 使用相同的DEF-USE機制， 如圖 所示 。 到目前為止，最大的好處就是也可以 直接 將此 Shape 用於圖形目的。 後來，對於某些傳感器，該機制將變得非常有用。 \n \n DEF-USE mechanism on the Sphere node called BALL_GEOMETRY. \n Sphere節點上的DEF-USE機制稱為BALL_GEOMETRY。 \n \n Add Walls \n 添加牆 \n In order to verify your progression, implement by yourself four walls to surround the environment. The walls have to be defined statically to the environment. To understand the difference between static and dynamic, let\'s take a defined object (the ball) above the ground. If the \xa0 Physics \xa0 node is NULL, it will remain frozen in the air during the simulation (static case). If the \xa0 physics \xa0 field contains a \xa0 Physics \xa0 nodes, it will fall under the effect of gravity (dynamic case). \n 為了驗證您的進度，請自己實施四堵牆以包圍環境。必鬚根據環境靜態定義牆壁。要了解靜態和動態之間的區別，我們將定義的物體（球）放在地面上方。如果“ \xa0 物理” 節點為NULL，則在仿真過程中它將保持凍結狀態（靜態情況）。 如果該 physics 字段包含“ \xa0 物理” 節點，則它將屬於重力作用（動態情況）。 \n Use as much as possible the DEF-USE mechanism at the \xa0 Shape \xa0 level rather than at the Geometry level. Indeed it\'s more convenient to add an intermediate \xa0 Shape \xa0 node in the \xa0 boundingObject \xa0 field of the \xa0 Solid \xa0 node. The best Geometry primitive to implement the walls is the Box node. Only one \xa0 Shape \xa0 has to be defined for all the walls. The expected result is shown in \xa0 this figure . \n 在 Shape 級別而不是Geometry級別 ，盡可能使用DEF-USE機制 。 實際上 ，在 實體 節點 的 字段中 添加中間 Shape 節點 更為方便 。 實現牆的最佳幾何原語是Box節點。 所有牆壁 僅需 定義 一個 形狀 。 預期結果如圖 所示 。 \n \n Solution: World File \n 解決方案：世界文件 \n To compare your world with the solution, go to your files and find the folder named "my_first_simulation" created in\xa0 Tutorial 1 , then go to the "worlds" folder and open with a text editor the right world.\xa0 This solution \xa0as the others is located in the\xa0 solution directory . \n 要將您的世界與解決方案進行比較，請轉到文件，找到在 教程1中 創建的名為“ my_first_simulation”的文件夾，然後轉到“ worlds”文件夾並使用文本編輯器打開正確的世界。 \xa0 與其他 解決方案 一樣， 該解決方案 位於 solution目錄中 。 \n \n The simulation state at the end of this second tutorial. \n 在第二篇教程結尾處的仿真狀態。 \n Efficiency \n 效率 \n The simulation of rigid bodies is computationally expensive. The simulation speed can be increased by minimizing the number of bounding objects, minimizing the constraints between them (more information about the constraints in the next tutorials), and maximizing the \xa0 WorldInfo.basicTimeStep \xa0 field. On each simulation, a \xa0 trade-off \xa0 has to be found between simulation speed and realism. \n 剛體的模擬在計算上是昂貴的。可以通過最小化邊界對象的數量，最小化邊界對象之間的約束（在下一個教程中有關約束的更多信息）以及最大化 WorldInfo.basicTimeStep 字段 來提高仿真速度 。 在每個模擬中， 必須在模擬速度和真實性之間找到 一個 折衷 。 \n Conclusion \n 結論 \n At the end of this tutorial, you are able to create simple environments based on rigid bodies. You are able to add nodes from the scene tree view and to modify their fields. You have become acquainted with the\xa0 Solid ,\xa0 Physics ,\xa0 Shape ,\xa0 Sphere \xa0and\xa0 Box \xa0nodes. You also saw the DEF-USE mechanism that allows to reduce node redundancy of the scene tree. \n 在本教程的最後，您將能夠基於剛體創建簡單的環境。您可以從場景樹視圖添加節點並修改其字段。您已經熟悉了 Solid ， Physics ， Shape ， Sphere 和 Box 節點。 您還看到了DEF-USE機制，該機制可減少場景樹的節點冗餘。 \n', 'tags': '', 'url': 'Webots User Guide Tutorial 2.html'}, {'title': 'NX教科書整理', 'text': '', 'tags': '', 'url': 'NX教科書整理.html'}, {'title': 'CH 2\xa0 入門教程', 'text': '這個章節介紹的是 NX12 的相關基礎說明，學習並理解與使用於建模 、 製圖等的 NX12 軟體。 \n 本章包含五個小節： 1. 打開 NX 12\xa0 \xa0 \xa0 2. 列印 、 保存和關閉零件文件\xa0 \xa0\xa0 3. 熟悉 NX 12 用戶界面\xa0 \xa0\xa0 4. 使用圖層\xa0 \xa0\xa0 5. 了解重要的命令和對話框。 \n 2.1啟動NX 12介面並打開文件 \n 2.1.1 啟動NX12 \n 在windows桌面點擊NX12圖示即可開啟。 \n 2.1.2\xa0 開啟新檔案 \n »按左上角的新增按鈕 \xa0或是按 Ctrl+ N \n 這將打開一個新視窗，詢問要創建的新文件的類型 、 名稱和位置。NX 12中有多種文件類型，可從位於 窗口的中心 的“模板(Templates)”對話框中選擇。所選文件的屬性顯示在“預覽(Preview)”右下側。由於我們要在建模環境中工作並創建新零件，因此僅指定工作環境的單位（英寸或毫米）以及名稱和位置文件。默認單位是毫米。 \n » 輸入文件的適當名稱和位置，然後點擊“OK”。 \n \n 2.1.3打開零件文件 \n » 單擊屏幕頂部的打開 (open) 或打開最近的零件按鈕 (open a Recent part)或 按 Ctrl+O \n 將顯示 “ 打開零件文件 ” 對話框。您可以在右側查看文件預覽 窗口。也可用 “ 預覽 ” 按鈕前面的小框來關閉 “ 預覽 ” 。 \n 2.2列印、儲存及關閉文件 \n 2.2.1 列印NX12圖像 \n » 按下檔案(File) →列印(Print) \n 2.2.2 儲存零件文件 \n 必須時常儲存工作。由於某些原因，NX 12會關閉，而零件如果沒有儲存，所有工作都會丟失。 \n »\xa0  按下檔案(File)→儲存(Save) \n 以下有五個選項可以儲存文件： \n 1.Save \n 2.Save Work Part Only(僅儲存工作零件):此選項將僅儲存活動部件在屏幕上。 \n 3.Save As(另存為):此選項允許您使用其他名稱和/或類型將零件保存在屏幕上，可使用多種檔案型式，如 IGES、STEP 203、STEP 214、AutoCAD DXF、AutoCAD DWG、CATIA Model和CATIA V5等。\xa0 \n 4.Save All(保存全部):此選項將使用現有名稱保存所有打開的零件文件。 \n 5.Save Bookmark(保存書籤):此選項會將屏幕快照和當前模型的上下文保存在屏幕上 作為.JPEG文件和書籤。 \n 2.3\xa0NX12 介面 \n 通過使用不同的圖標，NX 12的用戶界面變得非常簡單。 大部分的可以通過在屏幕上導航鼠標並單擊圖標來執行命令。鍵盤輸入主要限於輸入值和命名文件。 \xa0 \n 2.3.1滑鼠功能 \n 2.3.1.1滑鼠左鍵(在NX中稱為MB1) \n 用於選擇圖標、菜單和圖形屏幕上的其他實體。在任何功能上雙擊MB1都會自動打開“編輯對話框”。在實體上點擊MB1，使用戶可以快速使用如下圖所示的幾個選項。 \n \n 2.3.1.2 滑鼠中鍵 ( MB2) \n 鼠標中鍵（MB2）或滾動按鈕，用於通過按下來旋轉對象，按住並拖動。模型也可以繞單個軸旋轉。繞軸旋轉垂直於屏幕，將鼠標指針放在圖形屏幕的右邊緣附近，然後旋轉。同樣，對於垂直軸和垂直於屏幕的軸，點擊底部屏幕的上邊緣和上邊緣分別旋轉。如果您同時按住MB2位置幾秒鐘，它將固定旋轉點（出現橙色圓圈符號）您可以在對象周圍拖動以查看，如果是滾動按鈕，則可以通過滾動對象來放大和縮小。如果打開了任何彈出窗口或對話框，還可以執行“確定”命令。 \n 2.3.1.3 滑鼠右鍵 (MB3) \n 鼠標右鍵 (MB3) 用於開啟用戶界面彈出窗口菜單。您可以訪問後續彈出的選項取決於選擇模式和應用。點擊MB3時選擇功能將提供選項與該功能有關。 \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n 若單擊MB3並按住按鈕將在功能周圍顯示一組圖標。這些圖標帶有可應用於功能的可能命令。 \n \n 2 .4 \xa0 圖層 \n 圖層用於將對象存儲在文件中，並像容器一樣工作以將對象收集到文件中。以 有條理和一致的方式收集。   與簡單的視覺工具（例如顯示和隱藏）不同，圖層提供 一種永久的方式來組織和管理文件中對象的可見性和選擇性。 \n 使用NX 12，您可以使用“圖層”控制對像是可見還是可選。 一層是NX 12中所有對象必須具有的系統定義的屬性，例如顏色，字體和寬度。 NX 12中有256個可用圖層，其中之一始終是工作層。 256個圖層中的任何一個都可以被分配給四種狀態分類之一。 \n 工作層是在其上創建對象的層，並且始終可見並且可以選擇，而它仍然是工作層。啟動新零件文件時，第1層是默認的工作層。當工作層更改為另一種類型的層時，先前的工作層將自動變為“可選”，並且可以然後被分配為“僅可見”或“不可見”狀態。 \n 為一個或多個圖層分配狀態 »\xa0 選擇查看→圖層設置。 \n 2.5\xa0 座標系統 \n NX中有不同的坐標系。 三軸符號用於標識坐標系。 \n 2.5.1 絕對座標系統 \n \n \n \n \n \n \n 絕對坐標係是從 所有對像都被引用。   這是一個固定的坐標系， NX 12建模空間中每個對象的位置和方向是 與這個系統有關。   絕對坐標系 還提供了通用的參考框架 零件文件。   一個零件文件中X = 1，Y = 1和Z = 1的絕對位置是 其他零件文件中的相同位置。 \n \n \n \n \n \n \n \xa0 \n 2.5.2 工作座標系統 \n 工作坐標系（WCS）是您要用於構造時要使用的確定特徵的方向和角度。 WCS的軸表示為XC，YC和ZC。（“ C”代表“當前”）。 它是可能有多個坐標零件文件中的系統，但其中只有一個可以是工作坐標系。 \n \n 2.6 工具欄 \n 工具欄包含圖標，可作為許多功能的快捷方式。下圖即為工具欄的主要項目顯示。 但是，您可以找到更多不同的圖標功能命令，基於所選模塊以及如何模塊是定制的。點擊 右鍵現有工具欄上的任何位置，將提供其他工具欄的列表。 您可以 通過選中添加任何工具欄。 \n \n 您可以通過以下方式自定義NX 12界面的設置單擊資源欄上的“物件”選項。 \n 物件選項具有工具欄菜單的不同設置顯示在NX 12界面上。它可以讓你自定義您希望在工具欄中顯示的工具欄介面。 \n \n \n \n', 'tags': '', 'url': 'CH 2\xa0 入門教程.html'}, {'title': 'CH 3\xa0 平面草圖', 'text': '3.1 總覽 \n NX 12草圖是一組命名的曲線，這些曲線連接在一個字符串中，掃描後形成實體的草圖表示該零件的外邊界。曲線在草繪器中的平面上創建。首先，這些曲線的繪製沒有任何確切的尺寸。然後，維度應用約束和幾何約束以完全約束草圖。 \n •草圖可以旋轉 \n •草圖可以拉伸 \n •草圖可以沿參考線（線）進行掃掠 \n 使用草圖創建零件的優點是： \n •用於創建輪廓輪廓的曲線非常靈活，可用於建模不尋常的形狀。 \n •曲線是參數化的，因此具有關聯性，可以輕鬆更改或刪除它們。 \n •如果更改了繪製草圖的平面，則草圖將被更改相應的。 \n •當您想要控制特徵的輪廓時，草圖非常有用，尤其是當它可能將來需要更改。草圖可以快速，輕鬆地進行編輯 \n 3.2草圖 素描 \n 在 NX 12 中，可以使用兩種方法創建草圖。 \n 第一種方法在當前環境和應用。 \n ➢選擇菜單→插入→草圖 \n 在另一種方法中，您可以使用 \n ➢在主工具欄中選擇素描 \n 在完成標誌旁邊有三個有用的選項。你可以改變框中的草圖名稱。下一個是東方素描從而將視圖定向到草圖平面。如果模型文件是在草繪過程中旋轉，請單擊此圖標以查看在平行於屏幕的平面上繪製草圖重新附著將草圖附加到另一個平面上，基準平面或路徑，或更改草圖方向。它允許您將草圖重新附加到所需的平面，而無需重新創建所有曲線，尺寸和約束。 \n 3.3草圖曲線工具欄 \n 工具欄包含用於創建常用類型的圖標 曲線和样條曲線，編輯，擴展，修剪， 圓角等。每種類型的曲線都有不同的方法 選擇和創建方法。讓我們討論最多 常用選項。輪廓此選項會根據您在彈出工具欄中選擇的圖標創建直線和圓弧。您可以使用坐標系或輸入長度和線的角度 \n 線 \n 此選項將選擇性地僅創建直線。 \n 弧 \n 此選項通過兩種方法之一創建弧。第一個選項以三個順序創建弧 \n 第二個選項創建具有中心點，半徑和後掠角或按中心點的弧帶有起點和終點圈創建圓類似於創建圓弧，不同之處在於，圓是封閉的。 \n 快速修剪 \n 這將從曲線的交點修剪延伸的曲線。該選項顯示為如果每個實體與另一個實體相交，則將它們拆分，並刪除該部分已選擇。 \n Studio樣條線 \n 您可以使用極點或通過點創建基本樣條曲線（ B 樣條曲線和 Bezier ）。 \n 3.4約束工具欄 \n 所有曲線都是通過拾取點創建的。在 NX 12 中，智能約束是自動應用的，以下段落顯示瞭如何手動應用約束。 \n 尺寸約束 \n 通過給尺寸賦予固定實體（例如軸）的尺寸，可以消除自由度，平面，坐標系或模型中創建的任何現有實體幾何。這些尺寸可以是線性，徑向，角度等。您可以隨時編輯尺寸值在草圖繪製過程中雙擊尺寸。 \n 幾何約束除了尺寸約束外，還可以給出一些幾何約束來消除自由程度。它們包括平行，垂直，共線，同心，水平，垂直，等長等。該軟件具有查找以下可能約束的能力：所選實體。例如，將約束應用到下圖中的行上平行於矩形的左側（該線最初與矩形成一定角度）。 \n 顯示草圖 \n 約束單擊此圖標將顯示與該特定草圖中的實體相關的所有選項。 \n 顯示 / 刪除約束 \n 該窗口列出了與所選任何實體相關的所有約束和約束類型。您可以刪除任何列出的約束或更改約束的順序。狀態行中顯示不受約束的自由度數。所有應通過遵循約束模型來應用約束來消除這些約束。 \n 3.5範例 \n 3.5.1操作影片: \n \n 3.5.2操作影片: \n \n 3.5.3操作影片: \n \n 3.6練習 \n 3.6.1操作影片: \n \n', 'tags': '', 'url': 'CH 3\xa0 平面草圖.html'}, {'title': 'CH 4\xa0 3D建模', 'text': '4.1 功能 分別為圖元、參考特徵、掃描特徵、刪除特徵、選取特徵和自訂義。 4.1.1 圖元 可直接開啟以定義完成之實體，包括 : 方塊、圓柱、角錐和球。 4.1.2 參考特徵 可建立參考點、參考軸、參考平面或座標，方便後續工作。 4.1.3 掃描特徵 可用拉伸或旋轉截面來創建實體。包括 : 伸長長料、旋轉長料、掃略、管子和特殊掃略。 4.1.4刪除特徵 刪除多餘的部分。包括 : 孔、鑑座、插槽和凹槽。 4.1.5選取特徵 包括 : 薄殼、增厚、界線除料、選取、曲線。 *選取在Insert →Associative Copy中 *薄殼、增厚在Insert →Offset/Scale *曲線在Insert →Surface 4.1.6自訂義 可將常用工具新增在同一個列表。 \n 影片網址: https://youtu.be/Huljf6YStGs \n \n', 'tags': '', 'url': 'CH 4\xa0 3D建模.html'}, {'title': 'CH 5\xa0 草圖', 'text': '本章的目的是為設計人員 / 製圖員提供有關繪圖工具的足夠知識，以創建其設計的基本工程圖。製圖應用程序支持根據 ANSI 標準起草工程模型。在解釋了起草應用程序的基礎之後，我們將逐步介紹起草一些先前創建的模型的方法。 \n \xa05.1概述 \n 製圖應用程序旨在允許您直接從 3D 模型或裝配零件中生成和維護行業標準的工程圖。 Drafting 應用程序還提供了一套 2D 繪圖工具，可滿足 2D 中心設計和佈局要求。通過草繪，可以輕鬆地創建具有正交視圖，剖面圖，導入視圖，輔助視圖，尺寸和其他註釋的工程圖。 \n 繪圖應用程序基於如下圖所示的實體模型創建視圖。 \n \n 製圖應用程序的一些有用功能包括： \n 1 ）選擇第一個視圖後，可以添加其他正交視圖，並通過單擊幾個按鈕將其對齊。 \n 2 ）每個視圖都直接與實體關聯。 因此，當更改實體時，工程圖將隨視圖和尺寸一起直接更新。 \n 3）草稿註釋（尺寸，標籤和帶引線的符號）直接放置在工程圖上，並在更改實體時自動更新。 \n 5.2創建草稿 \n 1.打開文件 Arborpress_rack.prt \n 2.從 NX 12 界面中，選擇 File → Draft 如圖所示，或選擇 Application 選項卡並選擇 Drafting \n \n 首次打開“繪圖應用程序”時，會彈出一個窗口，要求輸入諸如模板，標準尺寸或自定義尺寸，單位和投影角度。 \n 1. 尺寸 \n 尺寸允許選擇圖紙的尺寸。可以創建一些標準模板，有幾種標準尺寸的圖紙可選擇。如果圖紙不適合標準尺寸的圖紙，還可以定義“自定義”尺寸的圖紙。 \n 2. 預習 \n 這顯示了模板的整體設計。 \n 3. 單位 \n 單位遵循父 3-D 模型的默認單位。如果從“製圖應用程序”開始，則需要在此處選擇單位。 \n 4. 投影 \n 可以選擇“第一角度”或“第三角度”投影方法。 \n \n \n 要開始使用“繪圖應用程序”，從創建“標準尺寸”圖紙開始： \n 1.單擊標準尺寸單選按鈕 \n 2.在尺寸窗口的下拉菜單中，選擇尺寸為 11 x 17 的圖紙 B 。 \n 3.使用下拉菜單並在“比例”下選擇“自定義比例”，將比例更改為 1:25 。 \n 4.點擊確定 \n \n 將打開“製圖應用程序”，並顯示以下屏幕。首先，先看一下“草稿應用程序界面”。 \n \n 將看到一個彈出對話框，它可以幫助我們選擇零件，視圖和其他選項。 \n 1.更改選項和視圖，然後單擊完成 \n 2.選擇插入→視圖→基礎，或在視圖組中單擊基礎視圖 \n 具有“視圖”和“比例”選項的“基本視圖”對話框將隨對象的浮動圖形一起顯示。 \n \n 3.選擇前面的視圖 \n 在屏幕上找到“前視圖”投影。移動鼠標光標，然後單擊要查看的位置。 \n 設置“前視圖”後，將彈出另一個對話框，要求在“圖紙邊界”內屏幕上的任何位置設置其他視圖。 \n 可以通過在第一個視圖上移動光標來找到不同的視圖。 如果要在關閉此文件或更改為其他命令模式後添加任何正交視圖 \n 4.選擇插入→視圖→投影視圖或從“視圖”組中選擇“投影視圖” \n \n 5.如果已關閉“投影視圖”對話框，則可以通過單擊視圖組中的“投影視圖”圖標來重新打開它 \n \n 6.移動光標並單擊以獲取其他視圖 \n 7.單擊“投影視圖”對話框上的“關閉”或按鍵盤上的 <Esc> 鍵以關閉窗口 \n 8.選擇菜單→首選項→起草，或單擊快速訪問工具欄中的圖標以找到起草首選項 \n \n 9.單擊查看選項卡按鈕 \n 10.取消選中顯示邊框上的刻度線，如下圖所示，然後單擊確定。 \n \n 還可以在這裡找到許多其他選項，例如小數位數，隱藏線，角度和螺紋。 \n 例如，可以在製圖首選項→中找到隱藏線的選項→視圖→公共→隱藏線 \n \n 5.3尺寸 \n 現在，我們要為這些視圖創建尺寸。 可以通過以下兩種方式之一插入尺寸： \n 1.選擇菜單→插入→尺寸 \n 或是 \n 2.單擊尺寸工具欄，如下圖所示 \n \n 3.單擊“點和邊”，移動鼠標並單擊適當的位置以繪製尺寸 \n 此窗口中的圖標有助於更改尺寸的屬性。 \n \n 4.單擊設置按鈕 \n 可以在這裡修改尺寸設置。 出現一個對話框，如下所示。 \n \xa0 第一個列表用於刻字。 這允許用戶證明並選擇幀大小。 \n 在“線條 / 箭頭”部分，您可以更改箭頭線的粗細，箭頭，角度格式等。 \n \n “公差”列表。可以在此處將公差更改為設計值。 \n \n 亦可以在此處修改顯示類型，數字所需的精度和其他類似選項。 \n 下一個圖標是“文本”選項，可用於編輯單位，文本樣式，字體和其他與文本相關的方面。 \n \n \n 5.在創建的第一個視圖（前視圖）上，單擊機架的左上角，然後單擊右上角 \n \n 將會出現代表這些點之間距離的尺寸。可以通過在屏幕上移動鼠標來放置尺寸的位置。 \n 6.要將尺寸設置到圖紙上，將尺寸放置在視圖上方，然後單擊鼠標左鍵，即使在創建尺寸後，也可以編輯尺寸的屬性。 \n 7.右鍵單擊剛創建的尺寸，然後選擇“設置”或“編輯顯示” \n 8.可以在此處修改字體，顏色，樣式和其他更詳細的信息 \n 9.為所有其他視圖指定尺寸，如下圖所示 \n \n 5.4剖面圖 \n 為同一零件創建一個剖面圖，以顯示孔的深度和輪廓。 \n 1.選擇插入→視圖→截面，或從功能區欄中的視圖組中單擊視圖截面圖標 \n 2.單擊基本視圖底部，如圖所示。 這將顯示帶有兩個箭頭標記的幻影線，以表示剖面的方向（橙色虛線，箭頭指向上方）。 \n \n 3.單擊視圖中間，如圖所示。 這將確定剖麵線（剖面）的位置 \n 現在，在視圖周圍移動光標以獲取剖面平面的方向。 保持箭頭垂直向上，並將剖面圖拖動到“基本視圖”的底部。 \n \n 如果有乾擾，請調整尺寸位置。 最終的圖紙頁應如下圖所示。 \n \n 5.5產品和製造信息 \n 產品和製造信息（ PMI ）是 NX 中的重要應用程序之一，它提供用於在 3D 環境中記錄產品的註釋工具。 PMI 應用程序包括一個全面的 3D 註釋環境，允許設計團隊將詳細信息（例如幾何尺寸和公差（ GD ＆ T ），表面光潔度，焊接信息，材料規格，註釋，政府安全信息或專有信息等）共享給 3D 模型。 \n \xa0 在下面的示例中，將打開零件文件，在 PMI 應用程序中的 3D 模型上創建尺寸和註釋，並學習如何將尺寸和註釋繼承到 Drafting 應用程序。 \n \xa0 1.打開文件 Impeller_impeller.prt \n 2.從 NX 12 界面中選擇 File → PMI （打開復選標記） \n \n 這應該在“工具”和“應用程序”選項卡之間創建一個附加的選項卡 PMI 。 \n 選擇“ \xa0 PMI ”選項卡以進入如下所示的 PMI 應用程序。 \n \n 在此模式下，功能區欄將具有“尺寸”，“註釋”，“自定義符號”，“補充幾何”，“特殊”和“安全標記”組。 每個小組都有幾個選項，可以幫助描述建模的 3D 零件。 例如，“尺寸”組，“表面粗糙度”和“註釋”組中的“標註”的尺寸選項。 \n 3.單擊快速圖標 \n 4.選擇葉輪的端面作為第一對象和第二對象，以插入線性尺寸或單擊“線性”圖標執行相同的任務 \n 5.單擊“尺寸”組中的“徑向”圖標 ，以在葉輪上插入孔和曲面的尺寸 \n 6.單擊補充幾何組中的中心線圖標，然後選擇葉輪的內表面以插入零件的中心線。 \n 7.單擊“註釋”組中的“註釋”圖標以提供任何註釋，或單擊“表面粗糙度”圖標，選擇對象，文本位置和引出線以插入特定的表面粗糙度詳細信息（如果需要） \n PMI 尺寸確定後，葉輪的 Trimetric 視圖將如下所示。 \n \n 8.保存文件，選擇“應用程序”選項卡，然後單擊功能區欄中的“繪圖”圖標 \n 9.按照上一節中介紹的類似步驟為 3D 零件創建工程圖圖紙 \n 在創建圖紙的過程中，在“視圖創建嚮導”中，選擇“繼承 PMI ”選項，然後選擇“與圖形對齊（整個零件）”，然後選中“將 PMI 繼承到圖形”選項。這將繼承 3D 模型的尺寸，並顯示在圖紙上， \n \n 5.6例子 \n 1.打開模型 Impeller_hexa-bolt.prt \n 2.選擇文件→起草或在應用程序選項卡中選擇起草 \n 3.在圖紙窗口中，選擇圖紙 E-34 X 44 並將比例值更改為 8.0 ： 1.0 \n 4.點擊確定 \n 5.選擇插入→視圖→基本視圖或單擊基本視圖圖標 \n 6.通過重複上一個示例中說明的相同步驟添加前視圖 \n 7.添加正交視圖，包括右視圖和頂視圖 \n 8.選擇首選項→起草 \n 9.取消選中視圖選項卡下顯示邊框旁邊的框 \n 屏幕將具有以下三個視圖。 \n \n \n \xa0 \n 為了可視化隱藏線， \n 1.選擇首選項→起草→查看 \n 或者 \n 2.選擇視圖，單擊鼠標右鍵，然後選擇“設置”，如下所示 \n 將彈出一個窗口，其中包含與視圖有關的各種選項。 \n \n 3.單擊隱藏線選項卡 \n 4.如下所示，將“進程隱藏線”更改為“虛線”，然後單擊“確定”。 \n 可以看到如下圖所示的隱藏線。 \n \n 現在，我們將繼續進行尺寸標註。 \n 1.選擇插入→尺寸→線性或單擊“尺寸”組中的“線性尺寸”圖標 \n 2.給出以下所有距離的垂直尺寸 ( 對於線程，我們將使用引導線 ) 。 \n 3.單擊工具欄中顯示的註釋圖標 \n 4.在打開的註釋窗口中，輸入以下文本。可以在符號選項卡上找到 Ø 和度數符 \n \n \n 右手 Ø0.20 x 1.5 螺距 0.05 ，角度 600 ➢在側視圖中單擊螺紋軸，按住鼠標並將“引線”線拖動到視圖旁邊。 放開鼠標，然後再次單擊以放置文本。 \n \n \n \n \n \n \n \n \n \n \n \n \n 5.關閉註釋編輯器 \n \xa0 \n 由於刻字的高度很小，因此我們將擴大字符大小以及箭頭大小。 \n 1..右鍵單擊 Lead 並選擇 Settings \n 2.單擊刻字選項卡 \n 3.在文本參數部分，增加高度以使引線清晰易讀 \n 4.單擊“行 / 箭頭”選項卡 \n 5.在格式部分，增加引線的長度 \n \xa0 現在，我們將添加其他尺寸和視圖。 \n 1.選擇插入→尺寸→徑向或在尺寸組中單擊徑向尺寸 \n 2.在頂視圖中單擊螺栓的圓以給出直徑尺寸 \n 3.單擊插入→視圖→基本視圖，然後單擊基本視圖 \n 4.選擇等軸測視圖並將其放置在屏幕上的某個位置 \n 最終圖如下所示。 記得保存。 \n \n 5.7練習 \n', 'tags': '', 'url': 'CH 5\xa0 草圖.html'}, {'title': 'CH 6\xa0 組裝模型', 'text': '第6章-裝配建模 \n 每天，我們都會看到許多將組件組裝成一個模型的示例，例如自行車，汽車和計算機。所有這些產品都是通過設計和製造單個零件，然後將它們裝配在一起而創建的。創建它們的設計師必須仔細計劃每個零件，以便它們都能完美地配合在一起以執行所需的功能。在本章中，您將學習在裝配體建模中使用的兩種方法。我們將以葉輪組件為例進行組件建模。該程序集的某些部分已經在較早的章節中進行了建模。 NX 12 Assembly是包含各個零件的零件文件。它們以這樣的方式添加到零件文件中，即零件實際上位於裝配體中並鏈接到原始零件。這樣就無需為計算機中的各個部件創建單獨的存儲空間。所有零件都是可選的，可在設計過程中用於信息和配合，以確保設計者想要的完美配合。下圖顯示瞭如何添加零部件以構成裝配體。 \n \n 6.1術語裝配 \n 裝配是指向零件和/或子裝配的指針的集合。裝配體是零件文件，其中包含零部件對象。零部件對象零部件對像是指向包含零部件幾何形狀的零件文件的非幾何指針。零部件對象存儲信息，例如圖層，顏色，參考集，零部件相對於文件系統中零部件的裝配體和路徑的位置數據。 NX 12用於工程設計123密蘇里科技大學零件零件是零件的一個零件文件，該零件在裝配體中指向。實際的幾何圖形存儲在零部件中，並且被引用，而不是由裝配體複製。零部件的出現零部件的出現是指向零部件文件中幾何圖形的指針。使用零部件實例來創建一個或多個零部件參考，而無需創建其他幾何體。參考集參考集是零部件或子裝配中的對象的命名集合，可用於簡化高層裝配中零部件的表示。 \n \n 6.2組裝方法創建任何組裝模型的基本方法有兩種。 \n •自上而下的方法 \n •自下而上的方法 \n 6.2.1自上而下的方法 \n 在此方法中，首先創建裝配零件文件，然後在該文件中創建零部件。然後對各個零件進行建模。這種類型的建模在新設計中很有用。 \n \n 6.2.2自下而上的方法 \n 首先以傳統方式創建零部件，然後將其添加到裝配零件文件中。當零件文件已經存在於先前的設計中並且可以重複使用時，此技術特別有用。 \n 6.2.3混合和匹配 \n 可以在必要時將這兩種方法結合使用，以增加裝配設計需求的靈活性。 6.3裝配和約束導航器裝配導航器和約束導航器位於屏幕左側資源欄中零件導航器的頂部。這些導航器向您顯示構成裝配體的各種內容，包括零件層次結構，零件名稱，有關零件的信息，例如零件是否為只讀，對像數以及約束狀態。 \n 6.4匹配約束 \n 將零部件對象添加到裝配零件文件後，每個零部件對像都將與現有對象配對。通過在裝配的零部件上分配配合條件，可以在這些零部件之間建立位置關係或約束。這些關係稱為配合約束。配合條件由一個或多個配合約束組成。有不同的配合約束，如下所述： \n 觸摸/對齊：選擇進行對齊的平面對象將是共面的，但是平面的法線將指向相同的方向。圓柱對象的中心線將彼此對齊。 \n 同心：約束兩個分量的圓形或橢圓形邊緣，以使中心重合，並且邊緣的平面共面。 \n 距離：這將在兩個對象之間建立一個+/-距離（偏移）值。 \n 平行：所選對象將彼此平行。 \n 垂直：所選對象將彼此垂直。 \n 鍵合：創建焊接並將零件焊接在一起以作為單個對象移動。 \n 居中：對象將在其他對象之間居中，即沿槽定位圓柱並將圓柱在槽中居中。 \n 角度：這將在要組裝的零部件上選擇的兩個對象實體之間固定一個恆定的角度 \n 6.5示例 \n 我們將組裝葉輪組件對象。您已經在前面的章節中對所有組件進行了建模。現在，我們必須將它們插入到組裝環境中，並應用約束以使它們相對於彼此定位。組裝完成後，我們可以創建分解圖並準備工程圖。在開始裝配建模之前，請在Hexabolt的葉輪下部殼體和葉輪上部殼體的每一側上分別製造三個通孔（每個殼體總共6個孔）。孔的直徑應為0.25，其位置應與下圖相似。確保下部和上部機殼在相同的位置上打孔，以便在組裝時匹配。 \n \n 6.5.1開始裝配 \n ➢創建新文件 \n ➢在“模型”選項卡下選擇“裝配” \n ➢將單位設置為英寸 \n ➢將其命名為Impeller_assembly.prt \n \n 或者，如果您在建模應用程序中並想開始組裝，則 \n ➢在“應用程序”選項卡中打開“組裝”選項，然後會出現一個新的“組裝”選項卡 \n 0 \n ➢單擊文件→程序集，如下所示 \n 0 \n 在“組件”選項中， \n •“添加”選項將添加其零件文件已創建的新組件對象。 \n •“新建”使您可以在使用自頂向下的裝配方法時在裝配文件中創建新的零部件幾何。裝配約束允許您創建裝配約束，而“移動零部件”則允許您將零部件重新放置在裝配中所需的位置。 \n 0 \n 6.5.2添加組件和約束 \n ➢選擇添加將彈出右側所示的對話框。您可以從現有文件中選擇零件文件（應該已經在“已加載零件”選項卡中顯示），也可以使用對話框中的“打開文件”選項來加載零件文件。這會將選定的零件文件加載到“加載的零件”對話框中。 \n ➢單擊“打開”圖標，然後選擇文件Impeller_upper-casing.prt。 \n ➢在“零件名稱”對話框中單擊“確定”。然後，我們需要設置一個位置來放置第一個零部件的坐標系。在“位置”組框中，保留“裝配位置”的默認“捕捉”選項。 \n ➢單擊選擇對象現在，您應該能夠以透明模式查看零件，如右側圖所示。 \n ➢單擊“點對話框”圖標並創建[0，0，0]的坐標。 \n ➢單擊“確定”退出“點對話框”。注意：可以隨意使用“循環方向”選項來設置不同的方向。 \n ➢在“放置”組框中，我們可以定義該組件的放置位置和放置方式。在這種情況下，我們會將選項保留為默認值。 \n ➢單擊“確定”退出“添加組件”對話框。然後，您將看到一個彈出對話框，如下圖所示。 \n 0 \n ➢單擊“是”為該零件創建一個“修復”約束。現在您所擁有的應該如下圖所示。 \n 讓我們繼續添加第二個組件，即下部外殼。 \n 0 \n ➢單擊裝配部分中的添加➢從“零件”或“打開”中選擇文件Impeller_lower-casing.prt➢在“位置”組框中，將選項更改為“絕對–工件”以將新零件放置在當前工件的絕對原點處零件 \n ➢在“放置”組框中，首先切換“移動”單選按鈕，然後將下殼體移離上殼體，以留出足夠的空間來選擇配合面。您將擁有的內容應該類似於下圖。 \n 0 \n ➢然後，切換約束單選按鈕。現在，讓我們配對上殼體和下殼體。您可以在“約束類型”框中的下拉菜單中訪問所有約束。在這裡，您可以看到不同的配合類型，這在上一節中已進行了說明。 \n ➢確保在“類型”對話框中選擇了“觸摸對齊”圖標。 \n ➢首先，選擇箭頭指向的面，如左圖所示。 \n ➢如右圖所示，在屏幕上單擊上殼體的表面。 \n 0 \n 您可能必須調整視圖才能選擇面。選擇這兩個面後，將自動添加“觸摸對齊”約束。讓我們添加另一個“觸摸對齊”約束。 \n ➢單擊上套管的法蘭➢單擊下套管的法蘭，您可能需要通過單擊“反”來反轉約束方向 \n 0 \n \n 下殼體相對於上殼體受到約束。現在讓我們添加葉輪。 \n ➢選擇裝配體→零部件→添加以將零部件添加到當前裝配體中 \n ➢打開文件Impeller_impeller.prt \n ➢在對話框中單擊確定➢選擇絕對–裝配體位置的工作零件 \n 0 \n \n ➢切換“約束”按鈕➢單擊“約束類型”框中的“距離”圖標➢選擇兩個面，首先在葉輪上，然後在殼體上，如下圖所示 \n \n \n 0 \n ➢在“放置”組的“距離”框中，輸入3的值。 \n ➢按Enter預覽當前組件。預覽可能會顯示葉輪的方向與我們想要的方向相反。 \n 0 \n ➢要更改零件的方向或距離方向，請在“放置”窗口中，單擊“幾何要約束”框中的“循環最後約束”按鈕，如下所示 \n 0 \n ➢同樣，將六個墊圈和六個六角螺母分別向下移動至-30和-35。這是裝配體的分解圖。您可以旋轉並查看其外觀。 \n 0 \n 如果要返回原始未爆炸視圖，請單擊功能區中的爆炸視圖→從下拉菜單中選擇（不爆炸），如下所示 \n 0 \n 6.6.3千斤頂千斤 \n 頂螺釘是一種通過轉動導螺桿來操作的千斤頂。在本練習中，將要求您建模，組裝和準備零件圖紙。所有尺寸均應以毫米為單位。為每個組件創建單獨的草稿。起草最終裝配並製作表格，列出各個零部件。大會草案應有分解圖。 \n 0 \n', 'tags': '', 'url': 'CH 6\xa0 組裝模型.html'}, {'title': 'CH 7\xa0 曲面建模', 'text': '在本章中，您將學習如何在NX 12中創建自由曲面。至此，您已經學習了使用“表單特徵”或“草圖繪製”創建模型的不同方法。 \n \n \n \n \n \n \n \n \n \n \n \n cad_history第18章 \n 7.1 概述 \n 在 NX 12 中，“自由格式功能”選項位於菜單→插入→表面 / 網格表面 / 掃描 / 法蘭表面和菜單→編輯→表面等不同位置，以進行更高級的操作。 \n 7.1.1 從點創建自由特徵 \n 如果您要構造或預先存在的數據僅包含點，則可以嘗試使用以下三個選項之一從給定點構建曲面。 \n 按 \xa0 Menu, \xa0 按 Insert → Surface \n Four Point Surface: \xa0 如果您有四個角點。 \n Through Points: \xa0 如果這些點形成一個矩形陣列。 \n From Poles: \xa0 如果定義的點形成與通過它們的線相切的矩形陣列。 \n \n 7.1.2 通過節字符串創建自由格式特徵 \n 如果構造幾何包含連接對象（曲線和邊）的字符串，則可以使用以下兩個選項之一來創建自由曲面。 \n 按 \xa0 Menu, \xa0 按 \xa0 Insert → Mesh Surface \n Ruled: \xa0 如果您有兩個大致平行的字符串 \n Through Curves: 如果三個或更多字符串大致平行。 \n Through Curve Mesh: 如果在每個方向（平行和垂直）上至少有四個弦且至少有兩個弦，則使用此命令。 \n Swept: \xa0 如果至少兩個部分字符串大致相同，則使用垂直 \n 7.1.3 從面孔創建自由特徵 \n 如果構造幾何包含圖紙或面，則可以使用以下兩個選項之一來構造自由曲面。 \n Offset Surface: \xa0 如果您要偏移面，請使用此選項。 \n Extension: \xa0 如果您有邊曲線或曲線，請使用此選項。 \n 7.2 自由格式功能建模 \n 讓我們來進行一些自由結構建模的練習，其中包括結構化點，點雲，曲線和麵。 \n 打開文件 freeform_thrupoints.pr \n 右鍵單擊工具欄，並確保已選中“曲面工具欄” \n \n 您將看到七行點。 \n 選 Insert →Surface →Through Points \n 對話框如下圖所示彈出。 \n Patch Type,\xa0 選 \xa0Multiple \n Closed Along, \xa0 選 \xa0 Neither \n Row Degree and Column Degree, \xa0 都選 \xa0 3. \n 按下 \xa0 OK \n \n \n 下一個對話框將如上圖所示 \n 按 Chain from All \n 選擇最左行的頂部起點和底部終點，如下圖所示 \n \n 點的第一行將突出顯示。 \n 重複相同的過程以選擇點的前四行。 \n 之後，將彈出一個窗口，詢問是否指定了所有點或是否要指定另一行。 \n \n 按 \xa0 Specify Another Row \xa0 直到所有行都被指定的 \n 指定所有行後，選擇“ All Points Specified ” \n 在“ Through Points ”窗口上單擊“ Cancel ” \n 您將看到如下所示的表面。 \n \n 7.2.2 使用點雲建模 \n 打開名為 freeform_cloud.prt 的文件 \n 點雲將如下所示。 \n \n 按 Insert → Surface → Fit Surface \n 將出現以下對話框。 \n \n 單擊屏幕上的，選擇屏幕上的所有點點雲。 \n 在 Fit Direction 下拉菜單中，選擇 Best Fit 。 這使點雲坐標係與原始系統匹配 \n 將 U 度和 V 度的默認值更改為 3 \n 按 \xa0 OK \n 最終表面將如下所示。 \n \n 7.2.3 使用曲線建模 \n 打開名為 freeform_thrucurves_parameter.prt 的文件 \n 曲線如下圖所示 \n \n 按下 \xa0Insert → Mesh Surface → Through Curves \n 選擇第一個 section string ，如下所示。 確保選擇圓弧左側的某個位置。 \n 方向矢量顯示在字符串的末尾。 \n \n 單擊鼠標中鍵 MB2 或單擊 Add New Set \n 單擊與第一個相似的下一條曲線，然後單擊鼠標中鍵MB2。 您可以看到兩條 \n 曲線之間生成的曲面，如下圖所示 \n \n 重複相同的過程以選擇其餘的字符串。 選擇每條曲線後，請記住單擊 MB2 （或“ Add New Set ”） \n Alignment, \xa0 按 \xa0 Parameter \n Patch Type, \xa0 按 \xa0 Single \n Construction, \xa0 按 \xa0 Simple \n 當選擇“簡單”選項時，系統將嘗試構建盡可能簡單的表面並最小化面片的數量。 \n 按 OK \n \n 7.2.4 使用曲線和面建模 \n 打開名為 freeform_thrucurves_faces.prt 的文件 \n \n 曲線和面將如上圖所示 \n 按 \xa0 Insert →Mesh Surface →Through Curves \n 選擇頂面的 edge1 \n 選擇 edge-2 ，然後單擊 MB2 \n 選擇 edge-3 \n 在對話框的“ Alignment ”部分下，取消選中“ Alignment ”複選框 \n 您將在屏幕上顯示以下形狀。 \n \n 確保所有箭頭都指向相同的方向（如果不是，請雙擊任意一個箭頭以反轉其方向）。 \n 在“ Alignment ”對話框中，選擇“ Parameter ” \n 在“ Continuity ”對話框的“ for First Section ”中，選擇“ \xa0 G2 （ Curvature) ”選項，然後選擇頂面的兩個色塊。 \n 按 \xa0 APPLY \n \n 現在選擇 edge-3 ，然後單擊 MB2 \n 選擇下平面的三個邊緣 \n 在“ for First Section ”的“ Continuity ”對話框中將選項更改為 G2 （ Curvature ） \n 選擇剛創建的表面，然後單擊 MB2 。 \n 對於“ Continuity ”的 ”Last Section” ，選擇“ \xa0 G2 （ Curvature ）”，然後選擇底部的三個色塊作為參考 \n 單擊 OK 退出 \n 最終的自由曲面應如下所示 \n \n 7.3 練習 \n 7.3.1 曲線練習 \n \n 上圖顯示了使用點作為“ Control Point ”或“ Through Points ”創建的三個曲線。 下表列出了每個曲線的對應點和建模類型。 \n \n （a）在Curve-1和Curve-2之間創建直紋曲面。 \n （b）沿+ Y方向拉伸Curve-3以創建參考曲面。 然後在Curve-2和Curve-3之間創建曲面，該曲面應與剛拉伸的參考曲面具有G1（切線）連續性。 \n 提示：您可以將這些點從文本文件導入NX。 首先，將點坐標保存到文本文件中。 然後，使用“NX File" -> "Import" -> "Points from File"將其導入。 \n 7.3.2 表面練習 \n \n 給定 2 個點集，這些點集存儲在“ \xa0 Fit curve.pts ”和“ \xa0 Fit surface.pts ”文件中（在文件夾中）。 \n （ a ）將這兩組點導入 NX 。 （上圖顯示了預期的結果） \n （ b ）根據“ \xa0 Fit curve.pts ”文件中的點創建樣條曲線。 您可以使用“ Fit Curve ”來創建它，調整“ Degree ”和“ Segments ”以獲得更好的擬合。 \n （ c ）根據“ \xa0 Fit surface.pts ”文件中的點創建自由曲面。 您可以使用“ Fit Surface ”來創建它，調整“ Degree ”和“ Patches ”的數量以獲得更好的擬合度。 \n （ d ）使用樣條曲線作為邊界沿 Z 方向修剪自由曲面。 預期結果類似於計算機鼠標的上表面。 \n 7.3.3 設計計算機鼠標 \n 對與以下所示類似的計算機鼠標進行建模（可以隨意搜索更多圖像作為參考），或者您可以提出一種新的設計然後對其進行建模。 \n \n 7.3.4 設計運動水壺 \n 設計運動水壺，並使用 NX （曲線和曲面）中的自由形狀功能對其建模。 \n \n', 'tags': '', 'url': 'CH 7\xa0 曲面建模.html'}, {'title': 'CH 8\xa0 有限元素分析', 'text': "第八章 有限元分析 \n 有限元分析（FEA）是有限元法（FEM）的預測結構或流體的響應特性所施加的因素，例如力，壓力，熱，和振動的實際應用。 \n 可以幫助工程師們有一個更好的了解產品的性能在製造和測試之前。 \n 8.1概述 \n 8.1.1元件形狀和節點 的元素可以被分類為基於維度數目和節點中的元素的數量不同的類型。以下是一些類型的用於離散元件組成。 \n 8.1.2 Solution Steps \n 啟動模擬>選擇材料特性>運用負載>運用邊界條件>嚙合機構>解決方案和結果 \n 8.1.3 Simulation Navigator \n 仿真Navigator提供的能力，激活現有的解決方案，創建新的，並通過創建和修改運動的物體使用創建的解決方案來構建機制。要顯示模擬導航 ➢在資源欄中單擊仿真Navigator選項卡如該圖所示 它顯示了模型創建仿真的列表。在每個模擬中，它顯示載荷，邊界條件，多種網孔的列表，結果，產生的等報告。 \n 8.2模擬CREATION \n ➢將文件複製並粘貼Impeller_impeller.prt到一個新的文件夾，以避免被改變向大會提出，如果該部分尚未在NX窗口中打開➢點擊新建→模擬 ➢打開此新複製的文件 \n 如果部分在NX已經打開，然後從頂部功能區欄，點擊應用程序→設計 或者➢點擊文件→所有應用程序→模擬→設計仿真 當你第一次打開設計仿真模塊的任何文件，它會自動彈出新的有限元與仿真對話框創建一個模擬。在彈出的對話框中，單擊確定以創建新的模擬。 那麼在接下來的彈出窗口的解決方案，您可以選擇解算器和分析類型。 默認的求解器類型的NX Nastran設計和分析類型結構。 ➢選擇確定以創建一個新的解決方案稱為方案一，將被顯示在模擬導航。在這裡，我們保持其他項目為默認值。 \n 現在，模擬導航將類似於下圖 \n 8.3材料性能 下一個步驟是將材料特性分配給該模擬的實體模型。因為我們沒有在庫中的任何數據檢索標準的材料，我們將創建一個。讓我們假設，我們將用鋼管來製造葉輪。 \n 照著它的指示步驟一路做下去 \n 8.4網格劃分 網格選項離散化的模型成小的元件 \n 8.5荷載 施加在實體模型上的負載應是輸入到系統中。用於葉輪，假設主要力作用於渦輪機葉片的凹表面上。這種加載可以通過所有五個表面上正常的壓力近似。由於我們不關心負荷的大小，讓我們的價值為100磅/平方英寸英寸誇大葉片的變形。 \n 8.6邊界條件 葉輪繞圓錐體的軸與軸的軸旋轉，如您在前幾章的裝配中所看到的那樣。它不是固定的，但我們關心的是葉片相對於葉輪芯的變形。錐形芯相對固定，葉片的變形要進行相應的分析。 \n 8.7結果與模擬 8.7.1解決了模擬 的有限元模型，現在可以解決和分析。這是一個很好的做法，為模型完成第一次檢查之前，我們進入模型求解。要檢查模型 \n 8.7.2 FEA結果 \n 可以輕鬆地解釋從顏色編碼的結果。橘紅色顯示的最大變形區和藍色區域顯示的最小變形區。可以觀察到，由於錐形核心是固定的，它經歷零變形。 \n 8.7.3仿真和動畫 點擊頂部帶狀條結果選項卡上。一種用於動畫組上可以看到其如下 \n 可以看到負載應用到葉片葉輪變形的動畫。 \n 8.8練習 \n 8.8.1手扳壓機欄 打開文件“Arborpress_L-bar.prt'，做一個類似的結構分析，考慮材料如鋼。用於網格的元件的尺寸和類型應為'10'和'四（10）'。對於負載，與應用500的頂表面上的大小的常壓如示於下面的第一個圖。 \n 8.8.2 搖臂 在本練習中，您將檢查元素類型和網格大小對有限元分析結果的影響。打開第 4 章中建模的搖臂。分配以下材料屬性：Young 的模量 = 3.0 × 107 psi，泊森的比率 = 0.29，品質密度 = 7.35 × 10-4 slug/in3。修復計數器孔孔和計數器沉孔（即修復圓柱面），如下圖所示，並施加 600 psi 值的壓力負載，以正常顯示的面。對於以下四種情況中，分別獲取偏轉輪廓和 Von-Mises 應力輪廓。 \n", 'tags': '', 'url': 'CH 8\xa0 有限元素分析.html'}, {'title': 'CH 9\xa0 製造', 'text': '9.1.1創建空白頁 \n 創建新檔案或導入原始模型，建立胚料 \n 9.1.2設置加工環境 \n 選擇文件→\xa0新建→\xa0製造→\xa0選擇想要進行的加工模式 \n 9.1.3操作導航器 \n 有關刀具，方法和策略的信息 \n 9.1.4機器坐標系 \n 設定坐標系 \n 9.2.1創建新操作 \n 設定新的加工程序 \n 9.2.2工具創見與選擇 \n 創建刀具與設定刀具參數 \n 9.2.3工具路徑設置 \n 選擇刀具路徑的偏差量 \n 9.2.5切割深度 \n 設定每次切割的深度 \n 9.2.6切削參數 \n 設定切削參數 \n 9.2.7迴避 \n 設定起刀點及座標 \n 9.2.8速度和進給 \n 設定主軸轉速和切削速度 \n 9.3.1生成程序 \n 生成加工程序 \n 9.3.2刀具路徑顯示 \n 開啟刀去路徑顯示以檢視 \n 9.3.3刀具路徑模擬 \n 舍弟完刀具路徑後進行模擬，以避免產生撞刀之類的失誤 \n 9.3.4鑿孔檢查 \n 驗證工具是否從工件上清除了多餘的材料 \n 9.4.1粗加工 \n 粗加工以較快的速度去除散裝物料 \n 9.4.2半精加工 \n 半精加工程序旨在消除由於粗加工引起的不均勻 \n 9.4.3.1外部輪廓 \n 該程序旨在將外斜牆修整到地板的底部 \n 9.4.3.2內部輪廓 \n 觀察到切刀從未越過修整和檢查所給定的邊界 \n 9.4.4修整輪廓表面 \n 修整工件輪廓並開始加工 \n 9.5.1創建CLSF \n 生成並保存操作後，將生成的刀具路徑存儲為程序 \n 9.5.2後處理 \n 產生G碼 \n \n \n', 'tags': '', 'url': 'CH 9\xa0 製造.html'}, {'title': 'About', 'text': '此內容管理系統以\xa0 https://github.com/mdecourse/cmsimde \xa0作為 submodule 運作, 可以選定對應的版本運作, cmsimde 可以持續改版, 不會影響之前設為 submodule, 使用舊版 cmsimde 模組的內容管理相關運作. \n 利用 cmsimde 建立靜態網誌方法: \n 1. 在 github 建立倉儲, git clone 到近端 \n 2. 參考\xa0 https://github.com/mdecourse/newcms , 加入除了 cmsimde 目錄外的所有內容 \n 以 git submodule add\xa0 https://github.com/mdecourse/cmsimde \xa0cmsimde \n 建立 cmsimde 目錄, 並從 github 取下子模組內容. \n 3.在近端維護時, 更換目錄到倉儲中的 cmsimde, 以 python wsgi.py 啟動近端網際伺服器. \n 動態內容編輯完成後, 以 generate_pages 轉為靜態內容, 以 git add commit 及 push 將內容推到遠端. \n 4. 之後若要以 git clone 取下包含 submodule 的所有內容, 執行: \n git clone --recurse-submodules  https://github.com/mdecourse/newcms.git \n', 'tags': '', 'url': 'About.html'}, {'title': 'Develop', 'text': 'https://github.com/mdecourse/cmsimde \xa0的開發, 可以在一個目錄中放入 cmsimde, 然後將 up_dir 中的內容放到與 cmsimde 目錄同位階的地方, 使用 command 進入 cmsimde 目錄, 執行 python wsgi.py, 就可以啟動, 以瀏覽器 https://localhost:9443\xa0就可以連接, 以 admin 作為管理者密碼, 就可以登入維護內容. \n cmsimde 的開發採用 Leo Editor, 開啟 cmsimde 目錄中的 cmsimde.leo 就可以進行程式修改, 結束後, 若要保留網際內容, 只要將 cmsimde 外部的內容倒回 up_dir 目錄中即可後續對 cmsimde 遠端倉儲進行改版. \n init.py 位於\xa0 up_dir 目錄, 可以設定 site_title 與 uwsgi 等變數.', 'tags': '', 'url': 'Develop.html'}]};